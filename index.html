<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpDiff</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: rgb(32, 32, 32);
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            padding: 8px 20px;
            background: #2a2a2a;
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 10;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
        }

        .position-toggle {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .position-toggle:hover {
            background: #666;
        }

        .position-toggle:focus {
            outline: none;
        }

        .help-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .help-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
        }

        [data-help]:hover .help-tooltip {
            opacity: 1;
        }

        button[data-help] {
            position: relative;
        }

        .help-text-area {
            grid-column: span 2;
            background: #2a2a2a;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 12px;
            color: #999;
            line-height: 1.5;
            display: flex;
            align-items: center;
            min-height: 60px;
        }

        .help-text-content {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .help-text-content.show {
            opacity: 1;
        }

        .keyboard-hints {
            font-size: 11px;
            color: #999;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            margin: 0 2px;
            font-size: 10px;
        }

        .video-progress-container {
            flex: 1;
            height: 8px;
            background: rgba(160, 160, 160, 0.4);
            cursor: pointer;
            border-radius: 4px;
            overflow: hidden;
            user-select: none;
        }

        .video-progress-container:active {
            cursor: grabbing;
        }

        .video-progress-bar {
            height: 100%;
            background: rgb(160, 160, 160);
            width: 0%;
        }

        .video-timecode:hover {
            color: #fff;
        }

        .audio-source-selector button.active {
            background: rgb(160, 160, 160);
            color: #000;
            border-color: rgb(160, 160, 160);
        }

        .audio-source-selector button.muted {
            background: #2a2a2a;
            color: #666;
            text-decoration: line-through;
            border: 2px solid #ff4444;
            opacity: 0.6;
        }

        .audio-source-selector button.muted .audio-mute-icon {
            color: #ff4444;
        }

        .audio-source-selector button:hover {
            background: #666;
        }

        .audio-source-selector button.active:hover {
            background: rgb(180, 180, 180);
        }

        .audio-source-selector button.muted:hover {
            background: #333;
            opacity: 0.8;
        }

        .audio-mute-icon {
            font-size: 12px;
            cursor: pointer;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(160, 160, 160, 0.4);
            outline: none;
            border-radius: 2px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            background: rgb(160, 160, 160);
            cursor: pointer;
            border-radius: 50%;
        }

        .volume-slider::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: rgb(160, 160, 160);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .audio-source-selector {
            display: flex;
            gap: 4px;
        }

        .audio-source-selector button {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .video-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 10;
            flex-direction: column;
            align-items: center;
            min-width: 300px;
        }

        .video-controls.active {
            display: flex;
        }



        .quick-start-btn {
            padding: 4px 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 0;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .quick-start-btn:hover {
            background: #666;
        }

        .quick-start-popup {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: #242424;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            padding: 16px 20px;
            z-index: 1000;
            width: 360px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            display: none;
        }

        .quick-start-popup.show {
            display: block;
        }

        .quick-start-overlay {
            display: none;
        }

        .quick-start-close {
            float: right;
            background: transparent;
            color: #999;
            border: none;
            padding: 0;
            cursor: pointer;
            font-size: 11px;
            line-height: 1;
            margin-top: 2px;
        }

        .quick-start-close:hover {
            color: #ccc;
        }

        .comparison-view {
            flex: 1;
            position: relative;
            background: #000;
            display: none;
            min-height: 0; /* Allow flex child to shrink below content size */
        }

        .comparison-view.active {
            display: flex;
            flex-direction: column;
        }

        .overlay-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
        }

        .overlay-layer.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Media container: fills the layer, positioning context for JS-placed children */
        .media-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* video-wrapper: JS sets top/left/width/height to exact rendered media bounds in all modes */
        .video-wrapper {
            position: absolute;
            will-change: transform; /* promote to GPU compositor layer ‚Äî cheap to reposition */
        }

        /* Media fills the wrapper exactly ‚Äî object-fit:contain handled by JS sizing the wrapper */
        .video-wrapper img,
        .video-wrapper video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Info bar: JS positions it per mode (above video in overlay/horizontal, left in vertical) */
        .media-container > .asset-info-bar {
            position: absolute;
        }

        /* In overlay mode, only show info bar and zoom for the active layer */
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer:not(.active) .asset-info-bar,
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer:not(.active) .split-zoom-indicator {
            display: none;
        }

        /* Info bars always visible in split modes */
        body.side-by-side .asset-info-bar,
        body.vertical-stack .asset-info-bar,
        body.tripartite .asset-info-bar {
            display: flex;
        }

        body.side-by-side .overlay-layer {
            position: relative;
            width: 50%;
            display: inline-block;
            vertical-align: top;
        }

        body.side-by-side .overlay-layer.active,
        body.side-by-side .overlay-layer:not(.active),
        body.vertical-stack .overlay-layer.active,
        body.vertical-stack .overlay-layer:not(.active),
        body.tripartite .overlay-layer.active,
        body.tripartite .overlay-layer:not(.active) {
            opacity: 1;
            pointer-events: auto;
        }

        /* Horizontal split: layer height */
        body.side-by-side .overlay-layer {
            height: calc(100vh - 50px);
        }

        body.side-by-side .overlay-container {
            white-space: nowrap;
            overflow-x: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0;
        }

        /* Vertical stacking mode */
        body.vertical-stack .overlay-layer {
            position: relative !important;
            width: 100%;
            height: calc((100vh - 80px) / 3);
            display: block;
            margin-bottom: 0;
            overflow: hidden;
        }

        /* 2-asset vertical: divide by 2 not 3 */
        body.vertical-stack.two-asset .overlay-layer {
            height: calc((100vh - 70px) / 2);
        }

        body.vertical-stack .overlay-container {
            white-space: normal;
            overflow-y: visible;
            display: block;
            padding-bottom: 20px;
        }

        /* Tripartite: Original left-half, Edit A top-right, Edit B bottom-right */
        body.tripartite .overlay-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            height: calc(100vh - 50px);
            overflow: hidden;
            align-items: stretch;
            justify-items: stretch;
        }

        body.tripartite .overlay-layer {
            position: relative !important;
            width: 100% !important;
            height: 100% !important;
            display: block !important;
            align-items: unset !important;
            justify-content: unset !important;
            overflow: hidden;
        }

        body.tripartite .media-container {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
        }

        /* In all split modes the video-wrapper is JS-sized to exact rendered bounds.
           The media element must fill it 100%. Override the general overlay-layer rule
           (width:auto; height:auto) which has equal specificity but appears later. */
        body.side-by-side .overlay-layer img,
        body.side-by-side .overlay-layer video,
        body.vertical-stack .overlay-layer img,
        body.vertical-stack .overlay-layer video,
        body.tripartite .overlay-layer img,
        body.tripartite .overlay-layer video {
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
            object-fit: contain;
        }

        body.tripartite #layerOriginal {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        body.tripartite #layerEditA {
            grid-column: 2;
            grid-row: 1;
        }

        body.tripartite #layerEditB {
            grid-column: 2;
            grid-row: 2;
        }

        body.tripartite .asset-info-bar {
            display: flex;
        }

        body.tripartite .overlay-layer.active-audio .asset-info-bar {
            background: rgba(60, 60, 60, 0.95);
            color: #e0e0e0;
        }

        body.tripartite .overlay-layer.active-audio .asset-info-bar .asset-name {
            color: #ffffff;
        }

        /* fit-cover toggles */
        body.side-by-side.fit-cover .video-wrapper img,
        body.side-by-side.fit-cover .video-wrapper video,
        body.vertical-stack.fit-cover .video-wrapper img,
        body.vertical-stack.fit-cover .video-wrapper video,
        body.tripartite.fit-cover .video-wrapper img,
        body.tripartite.fit-cover .video-wrapper video {
            object-fit: cover;
        }

        /* Zoom level indicator - overlays bottom right corner of media */
        .split-zoom-indicator {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.85);
            padding: 4px 8px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 3px;
            pointer-events: none;
            z-index: 10;
            color: rgb(160, 160, 160);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: block; /* Always show in all modes */
        }

        /* Asset info bar styling */
        .asset-info-bar {
            display: none; /* Hidden by default in overlay; shown in split modes and active overlay layer */
            flex-direction: row;
            align-items: center;
            gap: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            font-size: 11px;
            color: #a0a0a0;
            border-radius: 3px;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
        }

        .asset-info-bar .asset-name {
            font-weight: bold;
            color: #ffffff;
        }

        /* Active asset indicator - brighter info bar in overlay mode */
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer.active .asset-info-bar {
            display: flex;
            background: rgba(60, 60, 60, 0.95);
            color: #e0e0e0;
        }

        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer.active .asset-info-bar .asset-name {
            color: #ffffff;
        }

        /* Active audio indicator for split views - shows which audio is playing */
        body.side-by-side .overlay-layer.active-audio .asset-info-bar,
        body.vertical-stack .overlay-layer.active-audio .asset-info-bar,
        body.tripartite .overlay-layer.active-audio .asset-info-bar {
            background: rgba(60, 60, 60, 0.95);
            color: #e0e0e0;
        }

        body.side-by-side .overlay-layer.active-audio .asset-info-bar .asset-name,
        body.vertical-stack .overlay-layer.active-audio .asset-info-bar .asset-name,
        body.tripartite .overlay-layer.active-audio .asset-info-bar .asset-name {
            color: #ffffff;
        }

        .layout-controls {
            display: none !important;
        }

        .overlay-layer img,
        .overlay-layer video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            width: auto;
            height: auto;
        }

        /* Keyboard shortcuts slide-in panel */
        .shortcuts-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }

        .shortcuts-backdrop.open {
            opacity: 1;
            pointer-events: auto;
        }

        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 300px;
            max-height: 70vh;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .shortcuts-panel.open {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        .shortcuts-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            background: #222;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .shortcuts-panel-header span {
            font-size: 13px;
            font-weight: 600;
            color: #ccc;
        }

        .shortcuts-panel-header button {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 4px;
            line-height: 1;
            border-radius: 3px;
        }

        .shortcuts-panel-header button:hover {
            background: #333;
            color: #ccc;
        }

        .shortcuts-list {
            margin: 0;
            padding: 8px 14px;
            overflow-y: auto;
            flex: 1;
        }

        .shortcut-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 6px 0;
        }

        .shortcut-key {
            flex-shrink: 0;
            min-width: 70px;
            color: #ccc;
            font-size: 14px;
            white-space: nowrap;
        }

        .shortcut-desc {
            color: #888;
            font-size: 14px;
        }

        .shortcuts-list kbd {
            background: #333;
            padding: 2px 7px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
            color: #bbb;
            margin: 0 1px;
            border: 1px solid #444;
        }

        .shortcut-divider {
            border: none;
            border-top: 1px solid #2a2a2a;
            margin: 4px 0;
        }

        .video-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 16px;
            border-radius: 6px;
            z-index: 10;
            display: none;
            min-width: 600px;
            max-width: 90vw;
        }

        .video-controls.active {
            display: block;
        }

        /* In split/stack views, position controls at bottom of viewport */
        body.side-by-side .video-controls,
        body.vertical-stack .video-controls,
        body.tripartite .video-controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 90vw;
            z-index: 100;
        }

        .video-controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .video-timecode,
        .video-duration {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: rgb(160, 160, 160);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .video-timecode:hover,
        .video-duration:hover {
            color: #fff;
        }

        .volume-icon {
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .volume-icon:hover {
            opacity: 0.8;
        }

        .identical-warning {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 193, 7, 0.95);
            color: #000;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }

        .identical-warning.show {
            display: block;
        }

        /* Overlay mode: pan cursor always active (zoom/pan available without mode gate) */
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-container {
            cursor: grab;
        }

        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-container.panning {
            cursor: grabbing;
        }

        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer img,
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer video {
            position: relative;
            transition: none;
        }

        .pan-hint {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 7px 18px;
            border-radius: 6px;
            font-size: 12px;
            color: #aaa;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .pan-hint.visible {
            opacity: 1;
        }

        .zoom-indicator {
            display: none; /* removed ‚Äî split-zoom-indicator on the image is sufficient */
        }

        #modeStrip, #assetStrip {
            display: flex;
            align-items: center;
            gap: 2px;
            position: relative; /* anchor the sliding underline */
        }

        /* Mode buttons slide left when overlay activates, right when leaving */
        @keyframes modeCoreSlideLeft {
            from { transform: translateX(var(--asset-group-width, 0px)); }
            to   { transform: translateX(0); }
        }
        @keyframes modeCoreSlideRight {
            from { transform: translateX(0); }
            to   { transform: translateX(var(--asset-group-width, 0px)); }
        }
        .mode-core {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .mode-core.sliding {
            animation: modeCoreSlideLeft 0.25s cubic-bezier(0.4, 0, 0.2, 1) both;
        }
        .mode-core.sliding-out {
            animation: modeCoreSlideRight 0.25s cubic-bezier(0.4, 0, 0.2, 1) both;
        }

        /* Asset group fades + slides in when overlay activates, out when leaving */
        @keyframes assetGroupReveal {
            from { opacity: 0; transform: translateX(8px); }
            to   { opacity: 1; transform: translateX(0); }
        }
        @keyframes assetGroupHide {
            from { opacity: 1; transform: translateX(0); }
            to   { opacity: 0; transform: translateX(8px); }
        }
        .asset-group {
            display: flex;
            align-items: center;
            gap: 0;
            margin-left: -6px; /* underlap OVERLAY pill's 4px border-radius so tint fills flush to its edge */
            opacity: 0;
        }
        .asset-group.visible {
            opacity: 1;
            animation: assetGroupReveal 0.25s cubic-bezier(0.4, 0, 0.2, 1) both;
        }
        .asset-group.hiding {
            animation: assetGroupHide 0.2s cubic-bezier(0.4, 0, 0.2, 1) both;
        }

        .mode-btn, .asset-btn {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.05em;
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            background: transparent;
            color: #777;
            transition: background 0.15s, color 0.15s;
            font-family: inherit;
        }

        .mode-btn:hover, .asset-btn:hover {
            background: #555;
            color: #fff;
        }

        .mode-btn.active {
            background: rgb(160, 160, 160);
            color: #000;
        }

        /* Asset sub-items: dim tint, no gap, square left edge so they connect to OVERLAY pill */
        .asset-btn {
            background: rgba(160, 160, 160, 0.4);
            transition: background 0.15s, color 0.15s;
            border-radius: 0;
            color: rgb(145, 145, 145);
        }

        /* First asset button: square left edge to seamlessly join the OVERLAY pill */
        .asset-btn.first-asset {
            border-radius: 0;
        }

        /* Last asset button: round the right end */
        .asset-btn.last-asset {
            border-radius: 0 4px 4px 0;
        }

        /* Asset separators (¬∑) share the dim tint so the band reads as one continuous strip */
        .strip-sep.asset-sep {
            background: rgba(160, 160, 160, 0.4);
            color: #555;
            padding: 4px 1px;
            margin: 0;
        }

        /* Active asset: slightly lighter text; underline is a separate sliding element */
        .asset-btn.active {
            background: rgba(160, 160, 160, 0.4);
            color: rgb(220, 220, 220);
        }

        /* Sliding underline bar ‚Äî positioned absolutely over the active asset button */
        #assetUnderline {
            position: absolute;
            bottom: 0;
            height: 2px;
            background: rgb(160, 160, 160);
            border-radius: 1px;
            pointer-events: none;
            transition: left 0.22s cubic-bezier(0.4, 0, 0.2, 1),
                        width 0.22s cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 0.15s ease;
            opacity: 0;
        }
        #assetUnderline.visible {
            opacity: 1;
        }

        .strip-sep {
            color: #444;
            font-size: 11px;
            padding: 0 1px;
            pointer-events: none;
            user-select: none;
        }

        .instructions {
            padding: 12px 20px;
            background: #2a2a2a;
            border-radius: 4px;
            margin: 10px 20px;
            font-size: 12px;
            line-height: 1.6;
        }

        .instructions h2 {
            font-size: 13px;
            margin-bottom: 8px;
            color: rgb(160, 160, 160);
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .instructions p {
            margin-top: 8px;
            font-size: 11px;
        }

        /* Load toast ‚Äî brief confirmation shown after files are assigned to slots */
        .load-toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.92);
            color: #ccc;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 300;
            pointer-events: none;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .load-toast.warning {
            color: #f5c542;
        }
        .load-toast.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="position: relative; display: flex; align-items: center; gap: 6px;">
                <span style="font-size: 16px; font-weight: 600;">WarpDiff</span>
                <button class="position-toggle" onclick="document.getElementById('multiFileInput').click(); this.blur();" id="loadBtn" data-help="Load 2‚Äì3 files to compare (or press L)" style="margin-left: 16px;">
                    Load
                    <div class="help-tooltip">Select 2‚Äì3 files to compare (auto-sorts by save time). Shortcut: L</div>
                </button>
                <input type="file" id="multiFileInput" accept="image/*,video/*" multiple onchange="handleMultiFileLoad(event)" style="display: none;">
                <button class="position-toggle" onclick="resetAll()" style="display: none;" id="resetBtn" data-help="Clear all assets and start over">
                    Reset
                    <div class="help-tooltip">Clear all assets and start over</div>
                </button>
                <button class="quick-start-btn" onclick="toggleQuickStart()">Help</button>

                <!-- Help Popup -->
                <div class="quick-start-popup" id="quickStartPopup">
                    <button class="quick-start-close" onclick="toggleQuickStart()">‚úï</button>
                    <p style="margin: 0 0 10px; font-size: 11px; font-weight: 700; letter-spacing: 0.05em; color: #aaa; text-transform: uppercase;">Help</p>
                    <ol style="margin: 0; padding-left: 18px; font-size: 13px; color: #ccc; line-height: 1.7;">
                        <li>Save files from Starfleet in order: Original, A, B</li>
                        <li>Select 2‚Äì3 files and drop onto this window, or press <kbd>L</kbd>
                            <ul style="margin: 3px 0 3px; color: #999; list-style: disc; padding-left: 16px;">
                                <li>2 files: Image/Video A vs Image/Video B</li>
                                <li>3 files: Original vs Edit A vs Edit B</li>
                            </ul>
                        </li>
                        <li>Files auto-sort by save time into the correct slots</li>
                        <li>Press <kbd>F</kbd> for fullscreen, <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> to compare</li>
                        <li>Press <kbd>+</kbd> <kbd>-</kbd> to zoom in/out</li>
                        <li>Press <kbd>Space</kbd> to play/pause videos</li>
                        <li>Press <kbd>K</kbd> for all hotkeys</li>
                    </ol>
                </div>
            </div>
            <!-- Mode strip: OVERLAY / 3-UP / COMPARE ‚Äî tappable, active one highlighted -->
            <div id="modeStrip" style="display:none;"></div>
            <!-- Asset strip: overlay mode only ‚Äî shows asset names, active one highlighted -->
            <div id="assetStrip" style="display:none;"></div>
        </div>

        <div class="comparison-view" id="comparisonView">
            <div class="overlay-container" id="overlayContainer">
                <!-- Layout controls for side-by-side mode -->
                <div class="layout-controls" id="layoutControls">
                    <button onclick="setViewMode('horizontal')" id="horizontalBtn" class="active">Horizontal</button>
                    <button onclick="setViewMode('vertical')" id="verticalBtn">Vertical</button>
                    <span style="color: #999; font-size: 11px; margin: 0 5px;">Drag to reorder</span>
                </div>
                
                <div class="overlay-layer" id="layerOriginal">
                    <div class="split-zoom-indicator" id="zoomOriginal">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">ORIGINAL</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                <div class="overlay-layer" id="layerEditA">
                    <div class="split-zoom-indicator" id="zoomEditA">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">EDIT A</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                <div class="overlay-layer" id="layerEditB">
                    <div class="split-zoom-indicator" id="zoomEditB">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">EDIT B</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                
                <div class="identical-warning" id="identicalWarning">
                    ‚ö†Ô∏è Identical Assets Detected
                </div>
                
                <div class="zoom-indicator" id="zoomIndicator">
                    2.0√ó
                </div>

                <div class="pan-hint">
                    Click and drag to pan
                </div>

                <div class="video-controls" id="videoControls">
                    <div class="video-controls-row">
                        <span class="video-timecode" id="videoTimecode" onclick="toggleTimecodeMode()" title="Click to toggle time/frame display">0:00:00</span>
                        <div class="video-progress-container" id="videoProgressContainer">
                            <div class="video-progress-bar" id="videoProgressBar"></div>
                        </div>
                        <span class="video-duration" id="videoDuration">0:00:00</span>
                        <div class="volume-control">
                            <span class="volume-icon" onclick="toggleMute()" id="muteBtn" title="Click to mute/unmute">üîä</span>
                            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" oninput="setVolume(this.value)">
                        </div>
                        <div class="audio-source-selector" id="audioSourceSelector">
                            <button onclick="selectAudioSource('original')" id="audioOriginal" class="active" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('original')">üîä</span>
                                O
                            </button>
                            <button onclick="selectAudioSource('editA')" id="audioEditA" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('editA')">üîä</span>
                                A
                            </button>
                            <button onclick="selectAudioSource('editB')" id="audioEditB" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('editB')">üîä</span>
                                B
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const mediaData = {
            original: null,
            editA: null,
            editB: null
        };

        const assetOrder = ['original', 'editA', 'editB'];

        // Returns the overlay-layer element for a given slot key ('original', 'editA', 'editB').
        // Centralises the slot‚ÜíDOM-id mapping so it doesn't have to be computed ad-hoc everywhere.
        const SLOT_LAYER_ID = { original: 'layerOriginal', editA: 'layerEditA', editB: 'layerEditB' };
        function getLayer(slot) { return document.getElementById(SLOT_LAYER_ID[slot]); }

        // Brief non-intrusive toast shown after file load. Auto-dismisses after `duration` ms.
        // Pass isWarning=true to tint the text amber (timestamp-collision advisory).
        let _toastTimer = null;
        function showLoadToast(message, isWarning = false, duration = 4000) {
            let toast = document.querySelector('.load-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.className = 'load-toast';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.classList.toggle('warning', isWarning);
            // Force reflow so re-triggering the transition works when called in quick succession
            toast.classList.remove('visible');
            void toast.offsetWidth;
            toast.classList.add('visible');
            clearTimeout(_toastTimer);
            _toastTimer = setTimeout(() => toast.classList.remove('visible'), duration);
        }

        let currentAssetIndex = 0;
        // isFullscreen removed ‚Äî zoom/pan always available in overlay; browser fullscreen via F key
        let hasVideos = false;
        let isMuted = false;
        let isPanning = false;
        let expectedFileCount = 0; // set by handleMultipleFiles; checkAllLoaded waits for this many
        let panStartX = 0;
        let panStartY = 0;
        let panOffsetX = 0;
        let panOffsetY = 0;

        let zoomLevel = 1; // Default 1x zoom (actual size/fit)
        let splitZoomLevel = null; // null = fit-to-panel; 1 = cap at 100% actual pixels (compare modes)
        let splitStepZoom = 1.0; // multiplicative zoom for split modes (1.0 = no extra zoom)
        let timecodeMode = 'time'; // 'time' or 'frames'
        let videoFrameRates = {}; // Store framerate for each video
        // Smooth multiplicative zoom: each step multiplies/divides by ZOOM_STEP.
        // ‚àö2 ‚âà 1.414 gives a classic "one stop" doubling every two steps.
        const ZOOM_STEP = Math.SQRT2;
        const ZOOM_MIN = 0.05;  // 5% ‚Äî effectively a hard floor
        const ZOOM_MAX = 32;    // 3200% ‚Äî hard ceiling
        let fitZoom = 1; // Fit-to-viewport zoom, computed when entering inspect mode

        // Cached header element ‚Äî queried once, reused by applyZoom / positionLabelsToMedia
        // instead of a live querySelector on every call.
        let _headerEl = null;
        function getHeaderEl() {
            if (!_headerEl || !_headerEl.isConnected) _headerEl = document.querySelector('.header');
            return _headerEl;
        }

        // Cached progress-bar UI elements ‚Äî queried once at startup, reused by
        // updateVideoProgress() which runs inside the rAF loop at 60fps.
        let _elProgressBar = null;
        let _elTimecode    = null;
        let _elDuration    = null;
        function getProgressEls() {
            if (!_elProgressBar) _elProgressBar = document.getElementById('videoProgressBar');
            if (!_elTimecode)    _elTimecode    = document.getElementById('videoTimecode');
            if (!_elDuration)    _elDuration    = document.getElementById('videoDuration');
        }

        // Cached pan targets: set in handlePanStart, reused every mousemove in
        // handlePanMove and clampPanOffsets without re-querying the DOM.
        let _panVw        = null; // active .video-wrapper during pan
        let _panInfoBar   = null; // active .asset-info-bar during pan
        let _panLayer     = null; // active .overlay-layer during pan

        // Debounced positionLabelsToMedia ‚Äî collapses rapid per-asset load events into one call
        // so normalization always runs after all loaded slots have reported their dimensions.
        let _positionDebounceTimer = null;
        function positionLabelsToMediaDebounced() {
            clearTimeout(_positionDebounceTimer);
            _positionDebounceTimer = setTimeout(positionLabelsToMedia, 150);
        }

        // Setup drag and drop ‚Äî listen on the whole page
        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files);
                if (files.length === 0) return; // DOM element drag (layer reorder), not a file drop
                handleMultipleFiles(files);
            }, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleMultiFileLoad(event) {
            const files = Array.from(event.target.files);
            handleMultipleFiles(files);
        }

        function handleMultipleFiles(files) {
            // Filter for images and videos only
            const mediaFiles = files.filter(f =>
                f.type.startsWith('image/') || f.type.startsWith('video/')
            );

            if (mediaFiles.length !== 2 && mediaFiles.length !== 3) {
                alert(`Please select 2 or 3 media files.\nYou selected ${mediaFiles.length} media file(s).\n\n2 files = Edit A vs Edit B (no original)\n3 files = Original vs Edit A vs Edit B`);
                return;
            }

            // Always start from a clean slate so stale state from a previous load
            // (e.g., a mediaData.original left over from a prior 3-file session) never
            // bleeds into the new load. This mirrors resetAll() but without the dialog.
            clearAllMedia();

            // Tell checkAllLoaded() how many files to wait for before activating the view.
            // Without this, it fires at loadedCount=2 during a 3-file load and calls
            // setViewMode('horizontal'), which hides the empty third layer ‚Äî causing a
            // black screen when tripartite mode is set a moment later.
            expectedFileCount = mediaFiles.length;

            // Sort by lastModified timestamp (oldest to newest)
            const sortedFiles = mediaFiles.sort((a, b) => a.lastModified - b.lastModified);

            // Check if any two files have near-identical timestamps (within 2 s).
            // This can happen when files are batch-exported and timestamps are equalised.
            // In that case the sort order is arbitrary, so we warn the user.
            const TIMESTAMP_THRESHOLD_MS = 2000;
            let hasTimestampCollision = false;
            for (let i = 0; i < sortedFiles.length - 1; i++) {
                if (sortedFiles[i + 1].lastModified - sortedFiles[i].lastModified < TIMESTAMP_THRESHOLD_MS) {
                    hasTimestampCollision = true;
                    break;
                }
            }

            if (sortedFiles.length === 3) {
                // 3 files: oldest -> original, middle -> editA, newest -> editB
                loadFile('original', sortedFiles[0]);
                loadFile('editA', sortedFiles[1]);
                loadFile('editB', sortedFiles[2]);
                if (hasTimestampCollision) {
                    showLoadToast('Timestamps too close to sort reliably ‚Äî check slot order', true, 6000);
                } else {
                    const n = f => f.name.length > 22 ? f.name.slice(0, 20) + '‚Ä¶' : f.name;
                    showLoadToast(`Original: ${n(sortedFiles[0])}  ¬∑  A: ${n(sortedFiles[1])}  ¬∑  B: ${n(sortedFiles[2])}`);
                }
            } else {
                // 2 files: oldest -> editA, newest -> editB (no original)
                loadFile('editA', sortedFiles[0]);
                loadFile('editB', sortedFiles[1]);
                if (hasTimestampCollision) {
                    showLoadToast('Timestamps too close to sort reliably ‚Äî check slot order', true, 6000);
                } else {
                    const n = f => f.name.length > 28 ? f.name.slice(0, 26) + '‚Ä¶' : f.name;
                    showLoadToast(`A: ${n(sortedFiles[0])}  ¬∑  B: ${n(sortedFiles[1])}`);
                }
            }
        }

        function loadFile(slot, file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const dataUrl = e.target.result;
                const isVideo = file.type.startsWith('video/');
                
                mediaData[slot] = {
                    type: isVideo ? 'video' : 'image',
                    src: dataUrl,
                    name: file.name,
                    size: file.size,
                    lastModified: file.lastModified
                };

                // Load into overlay layer
                const layer = getLayer(slot);

                // Remove old media container but preserve info bars and zoom indicators at layer level
                const oldContainer = layer.querySelector('.media-container');
                if (oldContainer) {
                    oldContainer.remove();
                }

                // Create media container to hold the actual image/video
                const mediaContainer = document.createElement('div');
                mediaContainer.className = 'media-container';

                if (isVideo) {
                    const video = document.createElement('video');
                    video.src = dataUrl;
                    video.controls = false;
                    video.volume = 1.0;

                    video.addEventListener('loadedmetadata', function() {
                        if (mediaData[slot]) { mediaData[slot].w = video.videoWidth; mediaData[slot].h = video.videoHeight; }
                        updateResolutionDisplay(slot, video.videoWidth, video.videoHeight);
                        updateDurationDisplay(slot, video.duration);

                        // Setup video handlers
                        setupVideoHandlers(video, slot);

                        // Dimensions are now available ‚Äî safe to activate the view.
                        // checkAllLoaded() is called here (not in reader.onload) so that
                        // positionLabelsToMedia() always has valid videoWidth/videoHeight.
                        checkAllLoaded();

                        // Position labels after video loads ‚Äî debounced so all slots
                        // are measured together once rapid successive loads settle.
                        positionLabelsToMediaDebounced();

                    });

                    mediaContainer.appendChild(video);
                    hasVideos = true;
                } else {
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.addEventListener('load', async function() {
                        // Wait for image to be fully decoded before getting dimensions
                        try {
                            await img.decode();
                        } catch (e) {
                            console.warn('Image decode error:', e);
                        }

                        if (mediaData[slot]) { mediaData[slot].w = img.naturalWidth; mediaData[slot].h = img.naturalHeight; }
                        updateResolutionDisplay(slot, img.naturalWidth, img.naturalHeight);
                        updateSplitViewZoomIndicators();

                        // Dimensions are now available ‚Äî safe to activate the view.
                        // checkAllLoaded() is called here (not in reader.onload) so that
                        // positionLabelsToMedia() always has valid naturalWidth/naturalHeight.
                        checkAllLoaded();

                        // Debounced so all slots are measured together once rapid successive loads settle.
                        positionLabelsToMediaDebounced();
                    });
                    mediaContainer.appendChild(img);
                }

                // Find or create info bar and zoom indicator, then add to media container
                let infoBar = layer.querySelector('.asset-info-bar');
                let zoomIndicator = layer.querySelector('.split-zoom-indicator');

                // If they don't exist (shouldn't happen but safety check), create them
                if (!infoBar) {
                    infoBar = document.createElement('div');
                    infoBar.className = 'asset-info-bar';
                    const slotLabel = slot === 'original' ? 'ORIGINAL' : slot === 'editA' ? 'EDIT A' : 'EDIT B';
                    infoBar.innerHTML = `
                        <span class="asset-name">${slotLabel}</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    `;
                }

                if (!zoomIndicator) {
                    zoomIndicator = document.createElement('div');
                    zoomIndicator.className = 'split-zoom-indicator';
                    zoomIndicator.id = `zoom${slot.charAt(0).toUpperCase() + slot.slice(1)}`;
                    zoomIndicator.textContent = '1.0√ó';
                }

                // Build the asset structure:
                //   media-container (position:relative, fills layer)
                //     ‚îú‚îÄ‚îÄ asset-info-bar  ‚Üê JS-positioned per mode
                //     ‚îî‚îÄ‚îÄ video-wrapper   ‚Üê JS-sized to exact rendered video bounds
                //           ‚îú‚îÄ‚îÄ video/img
                //           ‚îî‚îÄ‚îÄ split-zoom-indicator  ‚Üê always bottom-right of wrapper

                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-wrapper';

                // Move the media element into the wrapper
                const mediaEl = mediaContainer.querySelector('img, video');
                if (mediaEl) videoWrapper.appendChild(mediaEl);

                // Zoom indicator lives inside the wrapper ‚Äî always at bottom-right of video bounds
                videoWrapper.appendChild(zoomIndicator);

                // Info bar is a sibling of video-wrapper ‚Äî JS positions it per mode
                mediaContainer.appendChild(infoBar);
                mediaContainer.appendChild(videoWrapper);

                layer.appendChild(mediaContainer);

                // NOTE: checkAllLoaded() is NOT called here. It is called from the
                // img.load / video.loadedmetadata callbacks instead, after naturalWidth /
                // videoWidth are available. Calling it here (reader.onload) meant
                // positionLabelsToMedia() ran before dimensions were known, so every
                // slot read naturalWidth=0 and the wrappers stayed invisible.
            };

            reader.readAsDataURL(file);
        }

        function updateResolutionDisplay(slot, width, height) {
            const resolution = `${width}√ó${height}`;
            const ratio = width / height;
            const standardRatios = [
                { value: 16/9, label: '16:9' },
                { value: 9/16, label: '9:16' },
                { value: 4/3, label: '4:3' },
                { value: 3/4, label: '3:4' },
                { value: 3/2, label: '3:2' },
                { value: 2/3, label: '2:3' },
                { value: 1.85, label: '1.85:1' },
                { value: 2.39, label: '2.39:1' },
                { value: 21/9, label: '21:9' },
                { value: 1, label: '1:1' }
            ];

            // Find closest standard ratio (within 1% tolerance)
            let aspectRatio = `${ratio.toFixed(2)}:1`;
            for (const std of standardRatios) {
                if (Math.abs(ratio - std.value) / std.value < 0.01) {
                    aspectRatio = std.label;
                    break;
                }
            }

            updateAssetInfoBar(slot, { resolution, aspectRatio });
        }

        function updateDurationDisplay(slot, duration) {
            if (!duration) return;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            updateAssetInfoBar(slot, { duration: durationStr });
        }

        function updateAssetInfoBar(slot, data) {
            const layer = getLayer(slot);
            if (!layer) return;

            const infoBar = layer.querySelector('.asset-info-bar');
            if (!infoBar) return;

            // Update resolution
            if (data.resolution) {
                const resElement = infoBar.querySelector('.asset-resolution');
                if (resElement) resElement.textContent = data.resolution;
            }

            // Update aspect ratio
            if (data.aspectRatio) {
                const aspectElement = infoBar.querySelector('.asset-aspect');
                if (aspectElement) aspectElement.textContent = data.aspectRatio;
            }

            // Update duration
            if (data.duration) {
                const durationElement = infoBar.querySelector('.asset-duration');
                if (durationElement) durationElement.textContent = data.duration;
            }
        }

        // Global progress update loop (shared across all videos)
        let globalAnimationId = null;

        // Cache the primary video reference so the rAF loop avoids querySelector every frame.
        // Updated by setupVideoListeners (on load) and switchToAsset (on asset change).
        let primaryVideoRef = null;

        function startProgressUpdateLoop() {
            // Only start if not already running
            if (globalAnimationId !== null) return;

            function updateLoop() {
                // Use the cached primary video ref; fall back to a live query only if stale
                let primaryVideo = primaryVideoRef;
                if (!primaryVideo || primaryVideo.isConnected === false) {
                    // Stale ref ‚Äî re-query once and re-cache
                    if (!isSplitMode) {
                        const activeLayer = document.querySelector('.overlay-layer.active');
                        primaryVideo = activeLayer ? activeLayer.querySelector('video') : null;
                    } else {
                        primaryVideo = document.querySelector('.overlay-layer video');
                    }
                    primaryVideoRef = primaryVideo;
                }

                if (primaryVideo && !primaryVideo.paused) {
                    updateVideoProgress(primaryVideo);
                    globalAnimationId = requestAnimationFrame(updateLoop);
                } else {
                    // Nothing is playing ‚Äî stop the loop; it restarts on the next play event
                    globalAnimationId = null;
                }
            }

            updateLoop();
        }

        function stopProgressUpdateLoop() {
            if (globalAnimationId !== null) {
                cancelAnimationFrame(globalAnimationId);
                globalAnimationId = null;
            }
        }

        function setupVideoHandlers(video, slot) {
            // Enable native looping
            video.loop = true;
            
            // Detect framerate from video metadata
            video.addEventListener('loadedmetadata', function() {
                videoFrameRates[video.src] = 30;
            });
            
            video.addEventListener('play', function() {
                // Sync all videos when any video plays
                document.querySelectorAll('video').forEach(v => {
                    if (v !== video) {
                        v.play();
                        if (Math.abs(v.currentTime - video.currentTime) > 0.5) {
                            v.currentTime = video.currentTime;
                        }
                    }
                });

                // Start global progress update loop (only once)
                startProgressUpdateLoop();
            });

            video.addEventListener('pause', function() {
                // Sync pause to all other videos
                document.querySelectorAll('video').forEach(v => {
                    if (v !== video && !v.paused) {
                        v.pause();
                    }
                });
            });
            
            video.addEventListener('seeked', function() {
                updateVideoProgress(video);
            });
        }

        let currentAudioSource = 'original';
        let audioMuteStates = {
            original: false,
            editA: false,
            editB: false
        };

        function toggleAudioMute(source) {
            // Toggle mute state for this source
            audioMuteStates[source] = !audioMuteStates[source];
            
            
            // Apply mute state IMMEDIATELY using volume (more reliable than muted property)
            applyAudioMuteImmediate(source);
            
            // Update button appearance
            const slotName = source.charAt(0).toUpperCase() + source.slice(1);
            const button = document.getElementById(`audio${slotName}`);
            if (!button) {
                return;
            }
            
            const icon = button.querySelector('.audio-mute-icon');
            
            if (audioMuteStates[source]) {
                button.classList.add('muted');
                icon.textContent = 'üîá';
            } else {
                button.classList.remove('muted');
                icon.textContent = 'üîä';
            }
            
            // If this was the selected audio source, switch to an unmuted source
            if (source === currentAudioSource && audioMuteStates[source]) {
                // Find first unmuted source
                const unmutedSource = Object.keys(audioMuteStates).find(s => !audioMuteStates[s] && mediaData[s]);
                if (unmutedSource) {
                    selectAudioSource(unmutedSource);
                }
            }
        }

        function applyAudioMuteImmediate(source) {
            const layer = getLayer(source);
            if (!layer) return;
            const video = layer.querySelector('video');
            if (!video) return;
            video.muted = audioMuteStates[source];
        }

        function selectAudioSource(source) {
            currentAudioSource = source;

            // Update button states
            document.getElementById('audioOriginal').classList.toggle('active', source === 'original');
            document.getElementById('audioEditA').classList.toggle('active', source === 'editA');
            document.getElementById('audioEditB').classList.toggle('active', source === 'editB');

            // Mute all videos except the selected source and update button icons
            ['original', 'editA', 'editB'].forEach(slot => {
                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const layer = getLayer(slot);
                const button = document.getElementById(`audio${slotName}`);
                const icon = button ? button.querySelector('.audio-mute-icon') : null;

                if (layer) {
                    const video = layer.querySelector('video');
                    if (video) {
                        // Mute if not the selected source OR if individually muted
                        const shouldMute = (slot !== source) || audioMuteStates[slot];
                        video.muted = shouldMute;

                        // Update mute icon to reflect actual state
                        if (button && icon) {
                            if (shouldMute) {
                                button.classList.add('muted');
                                icon.textContent = 'üîá';
                            } else {
                                button.classList.remove('muted');
                                icon.textContent = 'üîä';
                            }
                        }
                    }

                    // Add active-audio class to layer with unmuted audio in split views
                    if (slot === source && !audioMuteStates[slot]) {
                        layer.classList.add('active-audio');
                    } else {
                        layer.classList.remove('active-audio');
                    }
                }
            });
        }

        function setVolume(value) {
            const volume = value / 100;
            document.querySelectorAll('.overlay-layer video').forEach(v => {
                v.volume = volume;
            });
            // Volume label removed in compact redesign
        }

        // Single source of truth for timecode + duration display. Called directly during
        // scrubbing (with the seek target as currentTime) so the display tracks the cursor
        // instantly without waiting for the seek to land; also called by updateVideoProgress.
        function updateVideoProgressFromTime(video, currentTime) {
            const duration = video.duration;
            if (isNaN(duration) || duration === 0) return;
            getProgressEls();
            const fps = videoFrameRates[video.src] || 30;
            if (timecodeMode === 'frames') {
                const currentFrame = Math.floor(currentTime * fps);
                const totalFrames = Math.floor(duration * fps);
                _elTimecode.textContent = `Frame ${currentFrame}`;
                _elDuration.textContent = `${totalFrames}`;
            } else {
                // Time mode: "0:15:22" and "2:35:18" (min:sec:frame)
                const currentMinutes = Math.floor(currentTime / 60);
                const currentSeconds = Math.floor(currentTime % 60);
                const currentFrames = Math.floor((currentTime % 1) * fps);
                const totalMinutes = Math.floor(duration / 60);
                const totalSeconds = Math.floor(duration % 60);
                const totalFramesD = Math.floor((duration % 1) * fps);
                _elTimecode.textContent =
                    `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}:${currentFrames.toString().padStart(2, '0')}`;
                _elDuration.textContent =
                    `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}:${totalFramesD.toString().padStart(2, '0')}`;
            }
        }

        function updateVideoProgress(video) {
            const duration = video.duration;
            getProgressEls(); // ensure cache is warm (no-op after first call)

            // Guard against NaN when video metadata isn't ready yet
            if (isNaN(duration) || duration === 0) {
                _elProgressBar.style.width = '0%';
                _elTimecode.textContent = '0:00:00';
                _elDuration.textContent = '0:00:00';
                return;
            }

            _elProgressBar.style.width = (video.currentTime / duration) * 100 + '%';
            updateVideoProgressFromTime(video, video.currentTime);
        }

        function toggleTimecodeMode() {
            timecodeMode = timecodeMode === 'time' ? 'frames' : 'time';
            // Update display immediately
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const video = activeLayer.querySelector('video');
                if (video) {
                    updateVideoProgress(video);
                }
            }
        }

        function toggleQuickStart() {
            const popup = document.getElementById('quickStartPopup');

            if (popup.classList.contains('show')) {
                popup.classList.remove('show');
            } else {
                popup.classList.add('show');
            }
        }

        // Dismiss Help popup when clicking outside it
        document.addEventListener('mousedown', function(e) {
            const popup = document.getElementById('quickStartPopup');
            const btn = document.querySelector('.quick-start-btn');
            if (popup && popup.classList.contains('show') &&
                !popup.contains(e.target) && !(btn && btn.contains(e.target))) {
                popup.classList.remove('show');
            }
        });

        function checkForIdenticalAssets() {
            const identicalPairs = [];

            const slots = ['original', 'editA', 'editB'];
            const labels = {
                'original': 'Original',
                'editA': 'Edit A',
                'editB': 'Edit B'
            };

            // Compare all pairs for identical content.
            // Use name + size + lastModified rather than comparing full data URLs ‚Äî
            // data URLs can be 50-200 MB for video and block the main thread.
            for (let i = 0; i < slots.length; i++) {
                for (let j = i + 1; j < slots.length; j++) {
                    const slot1 = slots[i];
                    const slot2 = slots[j];
                    const d1 = mediaData[slot1];
                    const d2 = mediaData[slot2];
                    if (d1 && d2 &&
                        d1.name === d2.name &&
                        d1.size === d2.size &&
                        d1.lastModified === d2.lastModified) {
                        identicalPairs.push(`${labels[slot1]} = ${labels[slot2]}`);
                    }
                }
            }

            // Build combined warning message
            const warnings = [];
            if (identicalPairs.length > 0) {
                warnings.push(`Identical: ${identicalPairs.join(', ')}`);
            }

            // Show warning if any issues found
            const warningEl = document.getElementById('identicalWarning');
            if (warnings.length > 0) {
                warningEl.textContent = `‚ö†Ô∏è ${warnings.join(' | ')}`;
                warningEl.classList.add('show');
                
                // Auto-hide after 15 seconds (longer since there may be more info)
                setTimeout(() => {
                    warningEl.classList.remove('show');
                }, 15000);
            }
        }

        function switchToAsset(index) {
            // Skip empty slots
            const assetKey = assetOrder[index];
            if (!mediaData[assetKey]) {
                // If this slot is empty, try the next one
                const nextIndex = (index + 1) % assetOrder.length;
                if (nextIndex !== index) {
                    switchToAsset(nextIndex);
                }
                return;
            }
            
            currentAssetIndex = index;

            // Always switch audio to the selected video
            selectAudioSource(assetKey);
            
            const activeLayer = getLayer(assetKey);

            // Hide all layers (only in overlay mode)
            if (!isSplitMode) {
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    layer.classList.remove('active');
                });
                if (activeLayer) activeLayer.classList.add('active');
            }

            // Check if current asset is video and update progress if so
            const video = activeLayer ? activeLayer.querySelector('video') : null;
            if (video) {
                primaryVideoRef = video; // keep rAF loop ref fresh
                updateVideoProgress(video);
            }

            // Reposition the newly active layer's wrapper with the current zoom/pan offset.
            applyZoom();

            // Refresh active highlight and slide the underline to the new asset button
            refreshAssetButtons();
        }

        // Setup video scrubbing with drag support
        document.addEventListener('DOMContentLoaded', function() {
            const progressContainer = document.getElementById('videoProgressContainer');
            let isDragging = false;
            let wasPlaying = false;
            let pendingScrubPct = null; // latest scrub position waiting for next rAF
            let scrubRafId = null;      // rAF handle for pending seek

            // Cached scrub targets ‚Äî populated at mousedown, zero DOM queries during drag
            let _scrubVideo = null;       // primary (active) video element
            let _scrubAllVideos = null;   // all video elements (for sync)
            let _scrubContainerRect = null; // progress bar bounding rect (stable during drag)
            let _seekInFlight = false;    // true while the decoder is processing a seek

            // Seek a single video, preferring fastSeek() for keyframe-level speed.
            function seekVideo(v, time) {
                if (v.fastSeek) {
                    v.fastSeek(time);
                } else {
                    v.currentTime = time;
                }
            }

            // Flush the pending scrub: seek video(s) and update the UI.
            // Only fires when the decoder is idle (_seekInFlight === false) so seeks
            // never queue up inside the browser's media pipeline.
            // In overlay mode only the active (visible) video is seeked during drag;
            // hidden videos are synced on mouseup so they don't compete for the decoder.
            function flushScrub() {
                scrubRafId = null;
                if (pendingScrubPct === null) return;
                if (_seekInFlight) return; // decoder busy ‚Äî drop stale position, next seeked event will retry
                const pct = pendingScrubPct;
                pendingScrubPct = null;

                const video = _scrubVideo;
                if (!video || isNaN(video.duration)) return;

                // Update the progress bar immediately from mouse position (no seek lag)
                getProgressEls();
                if (_elProgressBar) _elProgressBar.style.width = (pct * 100) + '%';

                // Mark seek in-flight; cleared by the 'seeked' event on the primary video
                _seekInFlight = true;

                // Overlay mode: only seek the visible video during drag ‚Äî hidden videos
                // would compete for the decoder and slow down the one you're watching.
                // Compare/split modes: seek all videos in real time for sync preview.
                seekVideo(video, pct * video.duration);
                if (isSplitMode) {
                    const all = _scrubAllVideos;
                    if (all) {
                        for (let i = 0; i < all.length; i++) {
                            const v = all[i];
                            if (v !== video) seekVideo(v, pct * v.duration);
                        }
                    }
                }

                // Update timecode display from the seek target, not video.currentTime
                // (currentTime lags until the seek completes)
                updateVideoProgressFromTime(video, pct * video.duration);
            }

            function scrubToPosition(e) {
                const rect = _scrubContainerRect;
                const clickX = e.clientX - rect.left;
                pendingScrubPct = Math.max(0, Math.min(1, clickX / rect.width));

                // Immediately update progress bar so it tracks the cursor without waiting
                getProgressEls();
                if (_elProgressBar) _elProgressBar.style.width = (pendingScrubPct * 100) + '%';

                // Schedule one flush per animation frame ‚Äî rapid mousemoves collapse into one seek.
                // If a seek is already in-flight the rAF will find _seekInFlight=true and drop it;
                // the 'seeked' handler will schedule a fresh rAF to pick up whatever is pending.
                if (scrubRafId === null) {
                    scrubRafId = requestAnimationFrame(flushScrub);
                }
            }

            // Called when the primary video finishes a seek ‚Äî clears the in-flight flag
            // and immediately schedules another flush if the user moved the scrubber
            // while the decoder was busy (pendingScrubPct will be non-null in that case).
            function onScrubSeeked() {
                _seekInFlight = false;
                if (isDragging && pendingScrubPct !== null) {
                    if (scrubRafId === null) {
                        scrubRafId = requestAnimationFrame(flushScrub);
                    }
                }
            }

            progressContainer.addEventListener('mousedown', function(e) {
                isDragging = true;
                _seekInFlight = false;

                // Cache all scrub targets once at drag-start ‚Äî zero DOM queries during drag
                const activeLayer = document.querySelector('.overlay-layer.active');
                _scrubVideo = activeLayer ? activeLayer.querySelector('video') : null;
                _scrubAllVideos = Array.from(document.querySelectorAll('.overlay-layer video'));
                _scrubContainerRect = progressContainer.getBoundingClientRect();

                // Listen for seek completion on the primary video to pace the next seek
                if (_scrubVideo) {
                    _scrubVideo.addEventListener('seeked', onScrubSeeked);
                }

                // Pause video during scrubbing for smooth experience
                if (_scrubVideo) {
                    wasPlaying = !_scrubVideo.paused;
                    if (wasPlaying) {
                        pauseAllVideos();
                    }
                }

                scrubToPosition(e);
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    scrubToPosition(e);
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    // Flush any pending scrub so the final position is applied
                    if (scrubRafId !== null) {
                        cancelAnimationFrame(scrubRafId);
                        scrubRafId = null;
                        flushScrub();
                    }

                    // Remove the seeked listener and clear in-flight flag
                    if (_scrubVideo) {
                        _scrubVideo.removeEventListener('seeked', onScrubSeeked);
                    }
                    _seekInFlight = false;

                    // In overlay mode, hidden videos weren't seeked during drag ‚Äî
                    // sync them now to the final position before resuming playback.
                    if (!isSplitMode && _scrubVideo && _scrubAllVideos) {
                        const finalPct = _scrubVideo.duration
                            ? _scrubVideo.currentTime / _scrubVideo.duration
                            : 0;
                        for (let i = 0; i < _scrubAllVideos.length; i++) {
                            const v = _scrubAllVideos[i];
                            if (v !== _scrubVideo) seekVideo(v, finalPct * v.duration);
                        }
                    }

                    // Clear cached scrub targets
                    _scrubVideo = null;
                    _scrubAllVideos = null;
                    _scrubContainerRect = null;

                    // Resume playback if it was playing before
                    if (wasPlaying) {
                        playAllVideos();
                    }
                }
            });
        });

        // Browser fullscreen change handler ‚Äî recalculates layout when chrome disappears/reappears.
        document.addEventListener('fullscreenchange', () => {
            if (isSplitMode) {
                requestAnimationFrame(() => positionLabelsToMedia());
            } else {
                applyZoom();
            }
        });

        function applyZoom() {
            if (isSplitMode) return; // zoom/pan only applies in overlay mode

            const headerEl = getHeaderEl();
            const headerH = headerEl ? headerEl.offsetHeight : 50;

            // Compute a shared scale anchored to the narrowest asset's width.
            // Every asset is rendered so its width = minNW * sharedScale, giving identical
            // rendered widths for same-width assets and scaling wider ones down to match.
            // fitZoom is set so the widest rendered asset just fits the viewport at zoomLevel=1.
            let minNW = Infinity;
            {
                ['original', 'editA', 'editB'].forEach(slot => {
                    if (mediaData[slot]) {
                        const layer = getLayer(slot);
                        const media = layer && layer.querySelector('img, video');
                        if (media) {
                            const nw = media.naturalWidth || media.videoWidth || 0;
                            if (nw > 0 && nw < minNW) minNW = nw;
                        }
                    }
                });
                if (minNW === Infinity) minNW = 0;
                // fitZoom: scale so the narrowest (reference) asset fits the viewport
                const viewW = window.innerWidth;
                const viewH = window.innerHeight - headerH;
                if (minNW > 0) {
                    // fitZoom = scale that makes the narrowest asset's width fill the viewport.
                    // Height is also clamped: find the tallest rendered height across all assets
                    // at width-fit scale and ensure that fits vertically too.
                    let maxRenderedH = 0;
                    ['original', 'editA', 'editB'].forEach(slot => {
                        if (mediaData[slot]) {
                            const layer = getLayer(slot);
                            const media = layer && layer.querySelector('img, video');
                            if (media) {
                                const nw = media.naturalWidth || media.videoWidth || 0;
                                const nh = media.naturalHeight || media.videoHeight || 0;
                                if (nw > 0 && nh > 0) {
                                    // rendered height at width-fit scale = nh * (minNW/nw)
                                    const rh = nh * (minNW / nw);
                                    if (rh > maxRenderedH) maxRenderedH = rh;
                                }
                            }
                        }
                    });
                    fitZoom = Math.min(viewW / minNW, maxRenderedH > 0 ? viewH / maxRenderedH : Infinity);
                }
            }

            // Position each asset wrapper. Every asset is scaled so its rendered width equals
            // minNW * sharedScale ‚Äî same-width assets appear identically wide on screen.
            const availH = window.innerHeight - headerH;
            ['original', 'editA', 'editB'].forEach(slot => {
                if (!mediaData[slot]) return;
                const layer = getLayer(slot);
                if (!layer) return;
                const media = layer.querySelector('img, video');
                const vw = layer.querySelector('.video-wrapper');
                if (!media || !vw) return;

                const nw = media.naturalWidth || media.videoWidth || 0;
                const nh = media.naturalHeight || media.videoHeight || 0;
                if (!nw || !nh) return;

                // Scale this asset so its rendered width matches the narrowest asset's width.
                // (minNW/nw) normalises wider assets down; zoomLevel is already in px/naturalPx
                // units (fitZoom at fit-to-viewport, 1 at 100% actual pixels).
                const perAssetScale = minNW > 0 ? (minNW / nw) * zoomLevel : zoomLevel;
                const scaledW = Math.round(nw * perAssetScale);
                const scaledH = Math.round(nh * perAssetScale);
                const centerTop = headerH + Math.max(0, Math.round((availH - scaledH) / 2));
                const centerLeft = Math.max(0, Math.round((window.innerWidth - scaledW) / 2));

                // Pan is applied to the wrapper position directly (not as a media transform)
                // so the zoom badge and all wrapper children move with the image automatically.
                const pannedTop = centerTop + panOffsetY;
                const pannedLeft = centerLeft + panOffsetX;

                // Stash base (un-panned) coords and dimensions for handlePanMove() to use
                vw.dataset.centerTop = centerTop;
                vw.dataset.centerLeft = centerLeft;
                vw.dataset.scaledW = scaledW;
                vw.dataset.scaledH = scaledH;

                vw.style.position = 'fixed';
                vw.style.top = pannedTop + 'px';
                vw.style.left = pannedLeft + 'px';
                vw.style.width = scaledW + 'px';
                vw.style.height = scaledH + 'px';

                // Media fills its wrapper; no transform needed ‚Äî pan is on the wrapper
                media.style.imageRendering = zoomLevel >= 2 ? 'pixelated' : '';
                media.style.width = '100%';
                media.style.height = '100%';
                media.style.maxWidth = 'none';
                media.style.maxHeight = 'none';
                media.style.objectFit = 'contain';
                media.style.transform = '';

                // Update per-asset zoom badge (actual pixel ratio for this specific asset)
                const badge = vw.querySelector('.split-zoom-indicator');
                if (badge) badge.textContent = perAssetScale.toFixed(2) + '√ó';

                // Position info bar flush above the wrapper.
                // Store base (un-panned) coords so handlePanMove() can update cheaply.
                const infoBar = layer.querySelector('.asset-info-bar');
                if (infoBar) {
                    // Always read live offsetHeight here (not cached) ‚Äî the bar height can
                    // change on first render (font load, initial layout) and a stale cache
                    // causes the bar to separate from the video's top edge.
                    const ibH = infoBar.offsetHeight || 28;
                    infoBar._cachedH = ibH; // update cache for handlePanMove hot path
                    infoBar.dataset.centerTop = centerTop;
                    infoBar.dataset.centerLeft = centerLeft;
                    infoBar.dataset.scaledW = scaledW;
                    infoBar.dataset.headerH = headerH;
                    const clampedLeft = Math.max(0, pannedLeft);
                    infoBar.style.position = 'fixed';
                    infoBar.style.left = clampedLeft + 'px';
                    infoBar.style.top = Math.max(headerH, pannedTop - ibH) + 'px';
                    infoBar.style.width = Math.min(scaledW, window.innerWidth - clampedLeft) + 'px';
                    infoBar.style.right = '';
                    infoBar.style.bottom = '';
                    infoBar.style.height = '';
                }
            });
        }

        function zoomIn() {
            if (isSplitMode) {
                splitStepZoom = Math.min(splitStepZoom * ZOOM_STEP, ZOOM_MAX);
                positionLabelsToMedia();
                return;
            }
            zoomLevel = Math.min(zoomLevel * ZOOM_STEP, ZOOM_MAX);
            applyZoom();
        }

        function zoomOut() {
            if (isSplitMode) {
                splitStepZoom = Math.max(splitStepZoom / ZOOM_STEP, ZOOM_MIN);
                positionLabelsToMedia();
                return;
            }
            zoomLevel = Math.max(zoomLevel / ZOOM_STEP, ZOOM_MIN);
            applyZoom();
        }

        let panHintTimer = null;
        function showPanHint() {
            const hint = document.querySelector('.pan-hint');
            if (!hint) return;
            // Clear any running timer and reset
            clearTimeout(panHintTimer);
            hint.classList.add('visible');
            panHintTimer = setTimeout(() => {
                hint.classList.remove('visible');
            }, 2500);
        }

        function resetFitZoom() {
            if (isSplitMode) {
                splitStepZoom = 1.0;
                positionLabelsToMedia();
                return;
            }
            zoomLevel = fitZoom;
            panOffsetX = 0;
            panOffsetY = 0;
            applyZoom();
        }

        function setupPanHandlers() {
            const container = document.getElementById('overlayContainer');
            // Remove first to prevent double-attachment on repeated inspect entries
            container.removeEventListener('mousedown', handlePanStart);
            container.removeEventListener('mousemove', handlePanMove);
            container.removeEventListener('mouseup', handlePanEnd);
            container.removeEventListener('mouseleave', handlePanEnd);
            container.addEventListener('mousedown', handlePanStart);
            container.addEventListener('mousemove', handlePanMove);
            container.addEventListener('mouseup', handlePanEnd);
            container.addEventListener('mouseleave', handlePanEnd);
        }

        // Clamp panOffsetX/Y so each edge of the image can't travel more than
        // ~25% of the viewport past the corresponding side of the frame.
        function clampPanOffsets() {
            const vw = _panVw;
            if (!vw) return;
            const centerTop  = parseFloat(vw.dataset.centerTop  || 0);
            const centerLeft = parseFloat(vw.dataset.centerLeft || 0);
            const scaledW    = parseFloat(vw.dataset.scaledW    || 0);
            const scaledH    = parseFloat(vw.dataset.scaledH    || 0);
            const headerEl2  = getHeaderEl();
            const headerH    = parseFloat(headerEl2 ? headerEl2.offsetHeight : 50);
            const viewW = window.innerWidth;
            const viewH = window.innerHeight;
            const slackX = viewW * 0.25;
            const slackY = viewH * 0.25;

            // Right edge can't go more than slackX past the left of the viewport
            const minX = -(centerLeft + scaledW) + slackX;
            // Left edge can't go more than slackX past the right of the viewport
            const maxX = (viewW - centerLeft) - slackX;

            // Bottom edge can't go more than slackY above the header
            const minY = (headerH - centerTop - scaledH) + slackY;
            // Top edge can't go more than slackY below the viewport bottom
            const maxY = (viewH - centerTop) - slackY;

            panOffsetX = Math.min(maxX, Math.max(minX, panOffsetX));
            panOffsetY = Math.min(maxY, Math.max(minY, panOffsetY));
        }

        function handlePanStart(e) {
            if (zoomLevel <= fitZoom) return; // no pan when full image is visible
            e.preventDefault(); // Prevent browser's default drag behavior
            isPanning = true;
            panStartX = e.clientX - panOffsetX;
            panStartY = e.clientY - panOffsetY;
            document.getElementById('overlayContainer').classList.add('panning');
            // Cache the active layer's vw and infoBar so handlePanMove/clampPanOffsets
            // never query the DOM during the hot mousemove path.
            _panLayer   = document.querySelector('.overlay-layer.active');
            _panVw      = _panLayer ? _panLayer.querySelector('.video-wrapper') : null;
            _panInfoBar = _panLayer ? _panLayer.querySelector('.asset-info-bar') : null;
        }

        function handlePanMove(e) {
            if (!isPanning) return;

            e.preventDefault();
            panOffsetX = e.clientX - panStartX;
            panOffsetY = e.clientY - panStartY;
            clampPanOffsets();

            // Move the wrapper using cached refs set in handlePanStart ‚Äî no DOM queries
            const vw = _panVw;
            if (vw) {
                const centerTop  = parseFloat(vw.dataset.centerTop  || 0);
                const centerLeft = parseFloat(vw.dataset.centerLeft || 0);
                vw.style.top  = (centerTop  + panOffsetY) + 'px';
                vw.style.left = (centerLeft + panOffsetX) + 'px';
            }
            // Move info bar in lockstep
            const infoBar = _panInfoBar;
            if (infoBar) {
                const ibH = infoBar._cachedH || (infoBar._cachedH = infoBar.offsetHeight || 28);
                const barCenterTop  = parseFloat(infoBar.dataset.centerTop  || 50);
                const barCenterLeft = parseFloat(infoBar.dataset.centerLeft || 0);
                const barW          = parseFloat(infoBar.dataset.scaledW    || infoBar.offsetWidth);
                const barHeaderH    = parseFloat(infoBar.dataset.headerH    || 50);
                const pannedTop  = barCenterTop  + panOffsetY;
                const pannedLeft = barCenterLeft + panOffsetX;
                const clampedLeft = Math.max(0, pannedLeft);
                infoBar.style.top   = Math.max(barHeaderH, pannedTop - ibH) + 'px';
                infoBar.style.left  = clampedLeft + 'px';
                infoBar.style.width = Math.min(barW, window.innerWidth - clampedLeft) + 'px';
            }
        }

        function handlePanEnd(e) {
            isPanning = false;
            _panVw = null; _panInfoBar = null; _panLayer = null; // release cached refs
            document.getElementById('overlayContainer').classList.remove('panning');
            applyZoom(); // re-anchor info bars to the settled pan position
        }

        // Clear all loaded media and reset state ‚Äî called both by resetAll() and at the
        // start of handleMultipleFiles() so a fresh load always starts from a clean state.
        function clearAllMedia() {
            mediaData.original = null;
            mediaData.editA = null;
            mediaData.editB = null;
            currentAssetIndex = 0;
            expectedFileCount = 0;
            hasVideos = false;
            zoomLevel = 1;
            splitZoomLevel = null;
            splitStepZoom = 1.0;
            fitZoom = 1;
            panOffsetX = 0;
            panOffsetY = 0;
            isPanning = false;

            // Stop video progress loop ‚Äî will be restarted if new load includes videos
            stopProgressUpdateLoop();

            // Reset audio mute state and button UI for all slots
            ['original', 'editA', 'editB'].forEach(slot => {
                audioMuteStates[slot] = false;
                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const btn = document.getElementById(`audio${slotName}`);
                if (btn) {
                    btn.classList.remove('muted');
                    const icon = btn.querySelector('.audio-mute-icon');
                    if (icon) icon.textContent = 'üîä';
                }
            });
            currentAudioSource = 'original';

            // Reset global mute toggle and button label
            isMuted = false;
            const muteBtn = document.getElementById('muteBtn');
            if (muteBtn) muteBtn.textContent = 'üîä';

            // Reset timecode display mode and stale fps cache
            timecodeMode = 'time';
            videoFrameRates = {};

            document.body.classList.remove('fullscreen');
            document.body.classList.remove('side-by-side');
            document.body.classList.remove('vertical-stack');
            document.body.classList.remove('tripartite');
            document.body.classList.remove('two-asset');
            isSplitMode = false;
            viewActivating = false;
            layoutMode = 'horizontal';

            // Restore all layers to visible for next load
            document.querySelectorAll('.overlay-layer').forEach(layer => {
                layer.style.display = '';
            });
            document.getElementById('comparisonView').classList.remove('active');
            document.getElementById('resetBtn').style.display = 'none';
            // Hide mode and asset strips ‚Äî they'll be rebuilt when assets load
            document.getElementById('modeStrip').style.display = 'none';
            document.getElementById('assetStrip').style.display = 'none';
            document.getElementById('videoControls').classList.remove('active');

            // Clear layers
            ['Original', 'EditA', 'EditB'].forEach(slot => {
                const layer = document.getElementById(`layer${slot}`);
                // Remove media container
                const mediaContainer = layer.querySelector('.media-container');
                if (mediaContainer) {
                    mediaContainer.remove();
                }
                layer.classList.remove('active');

                // Reset info bar text
                const infoBar = layer.querySelector('.asset-info-bar');
                if (infoBar) {
                    const res = infoBar.querySelector('.asset-resolution');
                    const asp = infoBar.querySelector('.asset-aspect');
                    const dur = infoBar.querySelector('.asset-duration');
                    if (res) res.textContent = '-';
                    if (asp) asp.textContent = '-';
                    if (dur) dur.textContent = '-';
                }

                // Reset zoom indicator
                const zoomIndicator = layer.querySelector('.split-zoom-indicator');
                if (zoomIndicator) {
                    zoomIndicator.textContent = '1.0√ó';
                }
            });

            // Restore default asset labels (may have been changed to IMAGE/VIDEO A/B in 2-asset mode).
            // Use optional chaining: after clearAllMedia removes .media-container, .asset-name
            // may no longer exist in the DOM until the next loadFile() recreates it.
            const elEditA = document.querySelector('#layerEditA .asset-name');
            const elEditB = document.querySelector('#layerEditB .asset-name');
            if (elEditA) elEditA.textContent = 'EDIT A';
            if (elEditB) elEditB.textContent = 'EDIT B';

            // Reset file input
            document.getElementById('multiFileInput').value = '';
        }

        function resetAll() {
            if (confirm('Reset all assets and start over?')) {
                clearAllMedia();
            }
        }

        // Video controls
        function getAllVideos() {
            return [
                document.querySelector('#layerOriginal video'),
                document.querySelector('#layerEditA video'),
                document.querySelector('#layerEditB video')
            ].filter(v => v);
        }

        function playAllVideos() {
            getAllVideos().forEach(v => v.play());
        }

        function pauseAllVideos() {
            getAllVideos().forEach(v => v.pause());
        }

        function togglePlayPause() {
            const firstVideo = document.querySelector('.overlay-layer video');
            if (firstVideo) {
                if (firstVideo.paused) {
                    playAllVideos();
                } else {
                    pauseAllVideos();
                }
            }
        }

        function restartAllVideos() {
            getAllVideos().forEach(v => {
                v.currentTime = 0;
                v.play();
            });
        }

        let isSplitMode = false;
        let viewActivating = false;    // true while checkAllLoaded() activation is in progress for current load batch
        let layoutMode = 'horizontal'; // 'horizontal' or 'vertical'
        
        function updateSplitViewZoomIndicators() {
            // Only update in split view modes
            if (!isSplitMode && !document.body.classList.contains('vertical-stack')) {
                return;
            }
            
            ['original', 'editA', 'editB'].forEach(slot => {
                if (!mediaData[slot]) return;

                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const layer = getLayer(slot);
                const media = layer.querySelector('img, video');
                const indicator = document.getElementById(`zoom${slotName}`);

                if (!media || !indicator) return;
                
                // Get native dimensions
                const nativeWidth = media.naturalWidth || media.videoWidth || 0;
                const nativeHeight = media.naturalHeight || media.videoHeight || 0;
                
                if (nativeWidth === 0 || nativeHeight === 0) return;
                
                // Get displayed dimensions
                const displayedWidth = media.offsetWidth;
                const displayedHeight = media.offsetHeight;
                
                // Calculate zoom based on width (primary dimension)
                const zoomX = displayedWidth / nativeWidth;
                const zoomY = displayedHeight / nativeHeight;
                
                // Use the smaller zoom to ensure fit
                const actualZoom = Math.min(zoomX, zoomY);
                
                // Update indicator
                indicator.textContent = actualZoom.toFixed(2) + '√ó';
            });
        }
        
        // Zoom indicators are updated inside positionLabelsToMedia (split) / applyZoom (overlay),
        // both of which are debounced on resize below ‚Äî no separate listener needed.

        // Positions the video-wrapper and info bar to exactly match the rendered media bounds.
        // Works in all modes: overlay, horizontal split, and vertical split.
        // The video-wrapper is JS-sized to the exact rendered video pixels so that the
        // zoom indicator (position:absolute; bottom:5px; right:5px inside it) always lands
        // at the lower-right corner of the actual content, not the black letterbox area.
        // The info bar is positioned:
        //   - Overlay/Horizontal: above the video-wrapper (top edge)
        //   - Vertical: to the left of the video-wrapper
        function positionLabelsToMedia(retriesLeft = 5) {
            // In overlay mode, applyZoom() owns all wrapper positions.
            // positionLabelsToMedia only handles split modes (side-by-side, vertical-stack, tripartite).
            if (!isSplitMode) return;

            let anySkipped = false; // tracks if any slot had zero-dimension container (needs retry)
            const slots = ['original', 'editA', 'editB'];
            const isVertical = document.body.classList.contains('vertical-stack');
            const isTripartite = document.body.classList.contains('tripartite');
            const isOverlay = !isSplitMode && !isVertical;

            // In vertical-stack 100%-cap mode we shrink each layer to its video height and
            // center the group. Clear those overrides first so offsetHeight reads CSS values.
            if (isVertical) {
                slots.forEach(slot => {
                    const layer = getLayer(slot);
                    if (layer) { layer.style.height = ''; layer.style.marginTop = ''; }
                });
                const container = document.querySelector('.overlay-container');
                if (container) container.style.paddingTop = '';
            }

            // In tripartite mode, compute a shared rendered dimension so all three assets
            // appear the same size. Portrait assets (nw < nh) share rendered WIDTH;
            // landscape assets share rendered HEIGHT.
            // Original is flush-right; A/B are flush-left at the A/B boundary.
            const tripartiteLayout = {}; // slot ‚Üí { rw, rh, cw, ch, sharedZoom }
            if (isTripartite) {
                let minW = Infinity, minH = Infinity;
                let widthConstrained = false; // true = portrait assets ‚Üí share width; false ‚Üí share height
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const layer = getLayer(slot);
                    const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                    const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                    if (!media) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    // Use layer.offsetWidth/Height ‚Äî the true grid cell dimensions.
                    // mediaContainer is position:absolute so its offsetHeight may not
                    // reflect the grid row height correctly.
                    const cw = layer.offsetWidth;
                    const ch = layer.offsetHeight;
                    if (!cw || !ch) { anySkipped = true; return; }
                    // Mirror overlay mode: portrait = nw < nh ‚Üí width is the shared dimension
                    if (nw < nh) widthConstrained = true;
                    // EditB is flush-top; reserve space for its info bar so the image
                    // is sized to fit below the bar rather than behind it.
                    const ibEl = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;
                    const ibH = (slot === 'editB' && ibEl) ? (ibEl.offsetHeight || 28) : 0;
                    const availH = ch - ibH;
                    // Contain-fit rendered size within available cell height
                    const fitW = Math.min(cw, Math.floor(availH * nw / nh));
                    const fitH = Math.min(availH, Math.floor(cw * nh / nw));
                    tripartiteLayout[slot] = { nw, nh, cw, ch, ibH, fitW, fitH };
                    minW = Math.min(minW, fitW);
                    minH = Math.min(minH, fitH);
                });
                // Determine the effective zoom multiplier for tripartite rendering.
                // splitZoomLevel===1 means "smallest-resolution asset at 100% native pixels,
                // others scaled down to match its physical size" ‚Äî compute the multiplier
                // that achieves this using a longest-side anchor, then apply splitStepZoom on top.
                let tripartiteEffectiveZoom = splitStepZoom;
                if (splitZoomLevel === 1) {
                    // Find the smallest longest-side (= smallest-resolution asset's reference dim).
                    let tripartiteRefLong = Infinity;
                    slots.forEach(slot => {
                        const d = tripartiteLayout[slot];
                        if (!d) return;
                        const longest = Math.max(d.nw, d.nh);
                        if (longest < tripartiteRefLong) tripartiteRefLong = longest;
                    });
                    // The base size (at splitStepZoom=1) for the shared-dim anchor is minW or minH.
                    // We want the smallest-resolution asset to render at tripartiteRefLong native px.
                    // For landscape (share height): base = minH; target = tripartiteRefLong px of height
                    //   ‚Üí multiplier = tripartiteRefLong / minH (but clamp to fit)
                    // For portrait (share width): target = tripartiteRefLong px of width
                    //   ‚Üí multiplier = tripartiteRefLong / minW
                    if (widthConstrained && minW < Infinity) {
                        tripartiteEffectiveZoom = tripartiteRefLong / minW;
                    } else if (!widthConstrained && minH < Infinity) {
                        tripartiteEffectiveZoom = tripartiteRefLong / minH;
                    }
                    tripartiteEffectiveZoom *= splitStepZoom;
                }

                // Apply shared dimension: same width (portrait) or same height (landscape).
                // Then apply the effective zoom so +/- and 1 keys scale all three assets together.
                slots.forEach(slot => {
                    const d = tripartiteLayout[slot];
                    if (!d) return;
                    if (widthConstrained) {
                        // Portrait: share width, height follows aspect ratio
                        d.rw = Math.round(minW * tripartiteEffectiveZoom);
                        d.rh = Math.round(minW * tripartiteEffectiveZoom * d.nh / d.nw);
                        d.sharedZoom = d.rw / d.nw;
                    } else {
                        // Landscape: share height, width follows aspect ratio
                        d.rh = Math.round(minH * tripartiteEffectiveZoom);
                        d.rw = Math.round(minH * tripartiteEffectiveZoom * d.nw / d.nh);
                        d.sharedZoom = d.rh / d.nh;
                    }
                });
            }

            // Horizontal compare pre-pass: scale all assets so their longest side matches
            // the smallest longest-side across loaded assets. Anchoring on the longest side
            // ensures both landscape and portrait assets render at the same dominant dimension
            // (width for landscape, height for portrait), giving a consistent physical screen size.
            // Each slot then clamps independently to its own cell dimensions.
            let compareRefLong = 0;
            if (!isVertical && !isTripartite && !isOverlay) {
                let minLong = Infinity;
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const layer = getLayer(slot);
                    const media = layer ? layer.querySelector('img, video') : null;
                    if (!media) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    const longest = Math.max(nw, nh);
                    if (longest < minLong) minLong = longest;
                });
                compareRefLong = minLong === Infinity ? 0 : minLong;
            }

            // Overlay mode: find the smallest "longest side" across all loaded assets.
            // All assets are then rendered so their longest side equals that reference
            // length ‚Äî the smallest asset shows at 1:1, larger ones scale down to match.
            let overlayRefLong = 0;
            if (isOverlay) {
                let minLong = Infinity;
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const layer = getLayer(slot);
                    const media = layer ? layer.querySelector('img, video') : null;
                    if (!media) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    const longest = Math.max(nw, nh);
                    if (longest < minLong) minLong = longest;
                });
                overlayRefLong = minLong === Infinity ? 0 : minLong;
            }

            // Track rendered heights so the vertical-stack group-centering pass can use them.
            const slotRenderedH = {}; // slot ‚Üí rendered px height (for loaded slots only)

            // Vertical-stack pre-pass: anchor on the smallest longest-side across all loaded
            // assets, then find the largest shared scale factor that fits every asset's
            // longest-side-normalised dimensions within its cell.
            // Anchoring on the longest side (same as horizontal compareRefLong) ensures both
            // landscape and portrait assets render at the same dominant dimension on screen,
            // so different-resolution videos appear at the same physical size.
            let verticalRefLong = 0;
            let verticalSharedScale = null;
            if (isVertical) {
                // Step 1: find the smallest longest-side across all loaded assets.
                let minLong = Infinity;
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const layer = getLayer(slot);
                    const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                    const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                    if (!media || !mediaContainer) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    const longest = Math.max(nw, nh);
                    if (longest < minLong) minLong = longest;
                });
                verticalRefLong = minLong === Infinity ? 0 : minLong;

                // Step 2: find the largest scale such that every asset's normalised dimensions
                // fit within its cell. The per-slot rendering then uses:
                //   renderedW = nw √ó (verticalRefLong / longest) √ó verticalSharedScale
                //   renderedH = nh √ó (verticalRefLong / longest) √ó verticalSharedScale
                if (verticalRefLong > 0) {
                    slots.forEach(slot => {
                        if (!mediaData[slot]) return;
                        const layer = getLayer(slot);
                        const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                        const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                        const infoBar = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;
                        if (!media || !mediaContainer) return;
                        const nw = media.naturalWidth || media.videoWidth || 0;
                        const nh = media.naturalHeight || media.videoHeight || 0;
                        if (!nw || !nh) return;
                        const cw = mediaContainer.offsetWidth;
                        const ch = mediaContainer.offsetHeight;
                        if (!cw || !ch) return;
                        const ibH = infoBar
                            ? (infoBar._cachedH = infoBar.offsetHeight || 28)
                            : 0;
                        const availH = ch - ibH;
                        const longest = Math.max(nw, nh);
                        const baseW = nw * (verticalRefLong / longest);
                        const baseH = nh * (verticalRefLong / longest);
                        const fitScale = Math.min(cw / baseW, availH / baseH);
                        if (verticalSharedScale === null || fitScale < verticalSharedScale) {
                            verticalSharedScale = fitScale;
                        }
                    });
                    if (splitZoomLevel === 1 && verticalSharedScale !== null) {
                        verticalSharedScale = Math.min(verticalSharedScale, 1);
                    }
                }
            }

            slots.forEach(slot => {
                if (!mediaData[slot]) return;

                const layer = getLayer(slot);
                const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                const videoWrapper = mediaContainer ? mediaContainer.querySelector('.video-wrapper') : null;
                const infoBar = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;

                if (!media || !videoWrapper || !mediaContainer) return;

                // Get natural dimensions
                const naturalWidth = media.naturalWidth || media.videoWidth || 0;
                const naturalHeight = media.naturalHeight || media.videoHeight || 0;
                if (naturalWidth === 0 || naturalHeight === 0) return;

                // Get the container bounds
                const containerW = mediaContainer.offsetWidth;
                const containerH = mediaContainer.offsetHeight;
                if (containerW === 0 || containerH === 0) { anySkipped = true; return; }

                // In vertical-stack, reserve the top of each cell for the info bar so the
                // video is always fitted below it ‚Äî no overlap, no gap between cells.
                const ibReserve = (isVertical && infoBar)
                    ? (infoBar._cachedH = infoBar.offsetHeight || 28)
                    : 0;
                const fitH = containerH - ibReserve;

                let renderedW, renderedH, offsetX, offsetY;
                if (isOverlay && overlayRefLong > 0) {
                    // Scale each asset so its longest side = overlayRefLong px on screen.
                    // The asset with the shortest longest-side renders at 1:1 (100% zoom);
                    // larger assets scale down proportionally so they match that same footprint.
                    const longestSide = Math.max(naturalWidth, naturalHeight);
                    const scale = overlayRefLong / longestSide;
                    const baseW = Math.round(naturalWidth * scale);
                    const baseH = Math.round(naturalHeight * scale);
                    // Clamp to viewport in case even the reference asset is larger than the screen.
                    // Apply the same clampScale to the reference box too so the anchor is stable.
                    const clampScale = Math.min(1, containerW / overlayRefLong, fitH / overlayRefLong);
                    renderedW = Math.round(baseW * clampScale);
                    renderedH = Math.round(baseH * clampScale);
                    // Anchor: center the overlayRefLong √ó overlayRefLong reference box, then
                    // place each asset centered within that fixed box. This keeps the anchor
                    // point identical for all assets regardless of their individual heights.
                    const refPx = Math.round(overlayRefLong * clampScale);
                    const boxLeft = Math.round((containerW - refPx) / 2);
                    const boxTop  = Math.round((fitH - refPx) / 2);
                    offsetX = boxLeft + Math.round((refPx - renderedW) / 2);
                    offsetY = boxTop  + Math.round((refPx - renderedH) / 2);
                } else if (!isVertical && !isTripartite && compareRefLong > 0) {
                    // Horizontal compare: scale each asset so its longest side = compareRefLong,
                    // then apply splitStepZoom so +/- keys scale the whole group.
                    // Anchoring on the longest side gives the same dominant dimension on screen
                    // for both landscape (same width) and portrait (same height) pairs.
                    const longestSide = Math.max(naturalWidth, naturalHeight);
                    const refScale = compareRefLong / longestSide;
                    const baseW = naturalWidth * refScale;
                    const baseH = naturalHeight * refScale;
                    // Clamp to fit-to-viewport at base zoom (splitStepZoom=1); splitStepZoom
                    // can then push past the cell boundary (same as overlay zoom going past fit).
                    const clampScale = Math.min(containerW / baseW, fitH / baseH);
                    renderedW = Math.round(baseW * clampScale * splitStepZoom);
                    renderedH = Math.round(baseH * clampScale * splitStepZoom);
                    // Keep the whole group centered around the screen midpoint.
                    // At zoom > 1, images spill past their 50% cells ‚Äî centering on the
                    // full viewport width ensures symmetric overflow on both sides.
                    const loadedSlots = slots.filter(s => mediaData[s]);
                    const slotIdx = loadedSlots.indexOf(slot);
                    const nSlots = loadedSlots.length;
                    const gap = 16;
                    const groupW = renderedW * nSlots + gap * (nSlots - 1);
                    const groupLeft = Math.round((window.innerWidth - groupW) / 2);
                    // offsetX is relative to each cell's own origin (cell i starts at i * containerW)
                    offsetX = groupLeft + slotIdx * (renderedW + gap) - slotIdx * containerW;
                    offsetY = ibReserve + (fitH - renderedH) / 2;
                } else {
                    // Vertical-stack / tripartite / fallback: contain-fit per cell.
                    if (isVertical && verticalSharedScale !== null && verticalRefLong > 0) {
                        // Longest-side normalisation: scale each asset so its longest side
                        // matches verticalRefLong, then apply the shared fit scale so every
                        // asset occupies the same physical screen size regardless of resolution.
                        const longest = Math.max(naturalWidth, naturalHeight);
                        const normScale = verticalRefLong / longest;
                        renderedW = naturalWidth  * normScale * verticalSharedScale * splitStepZoom;
                        renderedH = naturalHeight * normScale * verticalSharedScale * splitStepZoom;
                    } else {
                        let scale;
                        const mediaAspect = naturalWidth / naturalHeight;
                        const containerAspect = containerW / fitH;
                        let fitScale;
                        if (containerAspect > mediaAspect) {
                            fitScale = fitH / naturalHeight;
                        } else {
                            fitScale = containerW / naturalWidth;
                        }
                        // Cap at 1.0 if 100% mode active (no upscaling past actual pixels)
                        scale = splitZoomLevel === 1 ? Math.min(fitScale, 1) : fitScale;
                        renderedW = naturalWidth  * scale * splitStepZoom;
                        renderedH = naturalHeight * scale * splitStepZoom;
                    }
                    offsetX = (containerW - renderedW) / 2;
                    // Center within the video area (below the reserved info-bar strip)
                    offsetY = ibReserve + (fitH - renderedH) / 2;
                    // Record for vertical-stack group-centering pass below
                    if (isVertical) slotRenderedH[slot] = Math.round(renderedH);
                }

                // In tripartite mode: use the shared zoom dimensions computed in the pre-pass.
                // Original is flush-right in its cell; EditA/EditB are flush-left in theirs.
                // All three are vertically centered. This makes right-edge of Original meet
                // the left-edge of A/B at the column midpoint, with the whole group centered.
                if (isTripartite && tripartiteLayout[slot]) {
                    const td = tripartiteLayout[slot];
                    const tw = Math.round(td.rw);
                    const th = Math.round(td.rh);
                    // Original: vertically centered in its full-height cell.
                    // EditA: bottom-aligned in its cell (image sits at the A/B boundary).
                    // EditB: top-aligned in its cell (image sits at the A/B boundary).
                    // This places A and B adjacent at their shared edge, matching Original's midpoint.
                    let ty;
                    if (slot === 'original') {
                        ty = Math.round((td.ch - td.rh) / 2);
                    } else if (slot === 'editA') {
                        ty = Math.round(td.ch - td.rh); // flush bottom
                    } else {
                        ty = td.ibH || 0; // flush top, below the info bar
                    }
                    // Original: flush right with 8px gap; A/B: flush left with 8px gap.
                    // 16px total between the centre column edges, matching compare mode.
                    const tx = slot === 'original'
                        ? Math.round(td.cw - td.rw) - 8
                        : 8;

                    videoWrapper.style.opacity = '0';
                    videoWrapper.style.width = tw + 'px';
                    videoWrapper.style.height = th + 'px';
                    videoWrapper.style.top = ty + 'px';
                    videoWrapper.style.left = tx + 'px';
                    videoWrapper.style.transform = '';
                    videoWrapper.style.transformOrigin = '';
                    videoWrapper.style.opacity = '';

                    const zoomIndicator = videoWrapper.querySelector('.split-zoom-indicator');
                    if (zoomIndicator) {
                        zoomIndicator.textContent = td.sharedZoom.toFixed(2) + '√ó';
                    }

                    if (infoBar) {
                        infoBar.style.position = ''; // clear fixed positioning from overlay mode
                        const ibH = infoBar.offsetHeight || 28;
                        infoBar.style.left = tx + 'px';
                        infoBar.style.width = tw + 'px';
                        infoBar.style.height = '';
                        infoBar.style.right = '';
                        // Place bar above the video-wrapper for all slots, clamped to 0.
                        infoBar.style.top = Math.round(Math.max(0, ty - ibH)) + 'px';
                        infoBar.style.bottom = '';
                    }
                    return; // skip the standard positioning below
                }

                // Size and position the video-wrapper to exactly cover the rendered media pixels.
                // Hide during the write so the browser never paints an intermediate state.
                videoWrapper.style.opacity = '0';
                videoWrapper.style.width = Math.round(renderedW) + 'px';
                videoWrapper.style.height = Math.round(renderedH) + 'px';
                videoWrapper.style.top = Math.round(offsetY) + 'px';
                videoWrapper.style.left = Math.round(offsetX) + 'px';
                videoWrapper.style.transform = '';
                videoWrapper.style.transformOrigin = '';
                videoWrapper.style.opacity = '';

                // In overlay mode the .overlay-layer img CSS rule sets width:auto which
                // prevents the image from filling the JS-sized wrapper. Force 100%√ó100%
                // so the image scales to exactly the wrapper dimensions.
                if (isOverlay) {
                    media.style.width = '100%';
                    media.style.height = '100%';
                    media.style.maxWidth = 'none';
                    media.style.maxHeight = 'none';
                }

                // Update zoom indicator to reflect actual displayed size
                const zoomIndicator = videoWrapper.querySelector('.split-zoom-indicator');
                if (zoomIndicator) {
                    const actualZoom = renderedW / naturalWidth;
                    zoomIndicator.textContent = actualZoom.toFixed(2) + '√ó';
                }

                // Position the info bar flush above the video, matching its width and x-position.
                // Clamp top to 0 so the bar never slides up into the header when the video is
                // centered in a tall cell and offsetY < ibH.
                if (infoBar) {
                    infoBar.style.position = ''; // clear fixed positioning from overlay mode
                    infoBar.style.bottom = '';
                    infoBar.style.height = '';
                    infoBar.style.right  = '';
                    const ibH = infoBar._cachedH = infoBar.offsetHeight || 28;
                    infoBar.style.left  = Math.round(offsetX) + 'px';
                    infoBar.style.top   = Math.round(Math.max(0, offsetY - ibH)) + 'px';
                    infoBar.style.width = Math.round(renderedW) + 'px';
                }
            });

            // Vertical-stack 100%-cap: shrink each layer to info-bar + video height so there's
            // no dead space, then center the whole group in the viewport.
            if (isVertical && splitZoomLevel === 1 && Object.keys(slotRenderedH).length > 0) {
                const headerEl = getHeaderEl();
                const headerH = headerEl ? headerEl.offsetHeight : 39;
                const availH = window.innerHeight - headerH;
                // margin-bottom is now 0; no separator between cells
                const loadedSlots = slots.filter(s => slotRenderedH[s] !== undefined);

                // Compute total height: each cell = ibReserve + renderedVideoH
                let totalH = 0;
                loadedSlots.forEach(slot => {
                    const layer = getLayer(slot);
                    const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                    const ib = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;
                    const ibH = ib ? (ib._cachedH || (ib._cachedH = ib.offsetHeight || 28)) : 0;
                    totalH += ibH + slotRenderedH[slot];
                });
                const topPad = Math.max(0, Math.round((availH - totalH) / 2));

                // Apply per-slot: shrink layer to ibReserve + video height; video stays at ibReserve
                loadedSlots.forEach(slot => {
                    const layer = getLayer(slot);
                    if (!layer) return;
                    const mediaContainer = layer.querySelector('.media-container');
                    const videoWrapper = mediaContainer ? mediaContainer.querySelector('.video-wrapper') : null;
                    const ib = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;
                    const ibH = ib ? (ib._cachedH || 28) : 0;
                    layer.style.height = (ibH + slotRenderedH[slot]) + 'px';
                    // Video positioned below the bar strip
                    if (videoWrapper) videoWrapper.style.top = ibH + 'px';
                    // Bar top: main loop already set correct left/width; just pin top to 0
                    if (ib) ib.style.top = '0px';
                });

                // Shift the first layer down to center the group
                const firstSlot = loadedSlots[0];
                const firstLayer = getLayer(firstSlot);
                if (firstLayer) firstLayer.style.marginTop = topPad + 'px';
            }

            // If any loaded slot had a zero-dimension container (layout not yet committed),
            // retry after the next paint so those slots get positioned correctly.
            // Cap retries to avoid infinite loops if a container is permanently zero.
            if (anySkipped && retriesLeft > 0) {
                requestAnimationFrame(() => positionLabelsToMedia(retriesLeft - 1));
            }
        }

        // Debounced applyZoom for resize events ‚Äî avoids running the full reposition
        // pipeline on every pixel of a window drag (fires 100+ times/sec).
        let _applyZoomResizeTimer = null;
        function applyZoomDebounced() {
            clearTimeout(_applyZoomResizeTimer);
            _applyZoomResizeTimer = setTimeout(applyZoom, 60);
        }

        // rAF-throttled positionLabelsToMedia for resize ‚Äî runs once per frame so
        // JS-positioned wrappers track the CSS grid in real time without the 150ms
        // debounce delay that causes jitter during window drag.
        let _positionRafPending = false;
        function positionLabelsToMediaRaf() {
            if (_positionRafPending) return;
            _positionRafPending = true;
            requestAnimationFrame(() => {
                _positionRafPending = false;
                positionLabelsToMedia();
            });
        }

        // Call positioning on resize
        window.addEventListener('resize', () => {
            if (isSplitMode) {
                positionLabelsToMediaRaf(); // rAF-throttled: smooth during window drag
            } else {
                applyZoomDebounced(); // debounced: avoid per-pixel reflow during window drag
            }
        });

        function setViewMode(mode) {
            // Update view mode
            if (mode === 'overlay') {
                // Return to overlay mode
                if (isSplitMode) {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.remove('tripartite');
                    document.body.classList.remove('two-asset');
                    document.body.classList.remove('zoom-100');
                    isSplitMode = false;
                    splitZoomLevel = null;
                    splitStepZoom = 1.0;

                    // Restore all layers to visible so overlay mode can show them
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.style.display = '';
                    });

                    // Clear inline styles set by positionLabelsToMedia() so CSS takes over in overlay mode
                    document.querySelectorAll('.video-wrapper').forEach(vw => {
                        vw.style.position = ''; // clear fixed positioning set by applyZoom()
                        vw.style.width = '';
                        vw.style.height = '';
                        vw.style.top = '';
                        vw.style.left = '';
                    });
                    document.querySelectorAll('.asset-info-bar').forEach(bar => {
                        bar.style.position = '';
                        bar.style.top = '';
                        bar.style.left = '';
                        bar.style.width = '';
                        bar.style.right = '';
                        bar.style.bottom = '';
                        bar.style.height = '';
                    });

                    // Reset audio mute states and button icons when leaving split view
                    ['original', 'editA', 'editB'].forEach(slot => {
                        audioMuteStates[slot] = false;
                        const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                        const layer = getLayer(slot);
                        if (layer) {
                            const video = layer.querySelector('video');
                            if (video) {
                                video.muted = false;
                            }
                        }
                        const button = document.getElementById(`audio${slotName}`);
                        if (button) {
                            button.classList.remove('muted');
                            const icon = button.querySelector('.audio-mute-icon');
                            if (icon) icon.textContent = 'üîä';
                        }
                    });

                    // Hide all layers except current
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.classList.remove('active');
                        // Remove active-audio class when leaving split view
                        layer.classList.remove('active-audio');
                    });
                    switchToAsset(currentAssetIndex);
                    // Two rAFs ensure CSS class changes reflow before applyZoom reads viewport.
                    // resetFitZoom() computes fitZoom then snaps zoomLevel to it, same as pressing 0.
                    // This ensures portrait/tall assets fit the viewport instead of rendering at 1:1.
                    requestAnimationFrame(() => requestAnimationFrame(() => resetFitZoom()));
                }
            } else {
                // Enable split view ‚Äî reset any compare-mode 100% cap
                splitZoomLevel = null;
                splitStepZoom = 1.0;
                document.body.classList.remove('zoom-100');

                if (!isSplitMode) {
                    isSplitMode = true;
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        const hasMedia = layer.querySelector('img, video');
                        if (hasMedia) {
                            layer.classList.add('active');
                        }
                    });
                    // Ensure only the current audio source plays
                    selectAudioSource(currentAudioSource);
                }

                // Apply body layout class FIRST so the CSS grid/flex is active before
                // we clear wrapper inline styles and measure offsetWidth. If the class
                // is added after the clear, positionLabelsToMedia() may read 0-dimension
                // cells (grid not yet committed) and bail, leaving wrappers invisible.
                layoutMode = mode;
                if (mode === 'vertical') {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('tripartite');
                    document.body.classList.add('vertical-stack');
                } else if (mode === 'tripartite') {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.add('tripartite');
                } else {
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.remove('tripartite');
                    document.body.classList.add('side-by-side');
                }

                // Show/hide layers based on whether they have media loaded.
                // Empty layers must be hidden so they don't take up space in the layout.
                // Exception: tripartite uses a CSS grid ‚Äî all 3 cells must remain in the DOM
                // and visible, or the grid collapses and renders black.
                const loadedSlotCount = Object.values(mediaData).filter(m => m !== null).length;
                if (mode !== 'tripartite') {
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        const hasMedia = layer.querySelector('img, video');
                        layer.style.display = hasMedia ? '' : 'none';
                    });
                } else {
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.style.display = '';
                    });
                }
                // two-asset class drives /2 height in vertical-stack instead of /3
                if (loadedSlotCount === 2) {
                    document.body.classList.add('two-asset');
                } else {
                    document.body.classList.remove('two-asset');
                }

                // Clear any inline styles set by positionLabelsToMedia() so CSS takes over.
                // Done AFTER the body class change so the layout is already live.
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    layer.style.height = '';    // clear vertical-stack 100%-cap height override
                    layer.style.marginTop = ''; // clear vertical-stack 100%-cap centering offset
                });
                document.querySelectorAll('.video-wrapper').forEach(vw => {
                    vw.style.position = ''; // clear fixed positioning set by applyZoom()
                    vw.style.width = '';
                    vw.style.height = '';
                    vw.style.top = '';
                    vw.style.left = '';
                    const zi = vw.querySelector('.split-zoom-indicator');
                    if (zi) { zi.style.bottom = ''; zi.style.right = ''; }
                });
                // Clear inline styles left on info bars by applyZoom() / handlePanMove() so
                // they don't stay at their overlay fixed-position coordinates while waiting
                // for positionLabelsToMedia() to run in the next rAF cycle.
                document.querySelectorAll('.asset-info-bar').forEach(bar => {
                    bar.style.position = '';
                    bar.style.top = '';
                    bar.style.left = '';
                    bar.style.width = '';
                    bar.style.right = '';
                    bar.style.bottom = '';
                    bar.style.height = '';
                });

                // Tripartite uses a CSS grid whose cell dimensions only stabilise after
                // a full layout pass. Three nested rAFs (vs two for other modes) give the
                // browser an extra paint cycle to commit grid row/column sizes before
                // positionLabelsToMedia() reads offsetWidth/offsetHeight.
                // Higher retry count (10 vs default 5) handles slower machines or busy
                // image-decode cycles that delay grid dimension availability.
                if (mode === 'tripartite') {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                updateSplitViewZoomIndicators();
                                positionLabelsToMedia(10);
                            });
                        });
                    });
                } else {
                    // Two nested rAFs guarantee a full layout pass with the new body class
                    // applied before we read offsetWidth/offsetHeight to compute positions.
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            updateSplitViewZoomIndicators();
                            positionLabelsToMedia();
                        });
                    });
                }
            }

            // Update mode and asset strips in header
            updateModeStrip(isSplitMode ? layoutMode : 'overlay');
            updateAssetStrip();
        }

        // Rebuilds the mode strip in the header. activeMode is 'overlay', 'tripartite',
        // 'horizontal', 'vertical', or 'compare' (the 2-asset auto-layout bucket).
        function updateModeStrip(activeMode) {
            const strip = document.getElementById('modeStrip');
            const loadedCount = Object.values(mediaData).filter(m => m !== null).length;
            if (loadedCount === 0) { strip.style.display = 'none'; return; }

            // Normalise activeMode: horizontal/vertical both map to 'compare' for highlighting
            const normalised = (activeMode === 'horizontal' || activeMode === 'vertical') ? 'compare' : activeMode;

            // If we're leaving overlay mode and the asset group is currently visible,
            // animate it out before rebuilding so the mode buttons slide back to the right.
            if (normalised !== 'overlay') {
                const existingAssetGroup = strip.querySelector('.asset-group.visible');
                const existingModeCore   = strip.querySelector('.mode-core');
                if (existingAssetGroup && existingModeCore) {
                    const groupW = existingAssetGroup.offsetWidth;
                    existingModeCore.style.setProperty('--asset-group-width', `${groupW}px`);
                    const underline = document.getElementById('assetUnderline');
                    if (underline) underline.classList.remove('visible');
                    existingAssetGroup.classList.remove('visible');
                    existingAssetGroup.classList.add('hiding');
                    existingModeCore.classList.remove('sliding');
                    existingModeCore.classList.add('sliding-out');
                    setTimeout(() => updateModeStrip(activeMode), 220);
                    return; // let the animation play; the setTimeout will rebuild
                }
            }

            strip.style.display = 'flex';
            strip.innerHTML = '';

            // Split mode first, OVERLAY last: 3-UP / OVERLAY or COMPARE / OVERLAY
            const modes = loadedCount === 3
                ? [['tripartite', '3-UP'], ['overlay', 'OVERLAY']]
                : [['compare', 'COMPARE'], ['overlay', 'OVERLAY']];

            // Wrap mode buttons in a flex group so they slide together
            const modeCore = document.createElement('div');
            modeCore.className = 'mode-core';

            modes.forEach(([mode, label], i) => {
                if (i > 0) {
                    const sep = document.createElement('span');
                    sep.className = 'strip-sep';
                    sep.textContent = '/';
                    modeCore.appendChild(sep);
                }
                const btn = document.createElement('button');
                btn.className = 'mode-btn' + (mode === normalised ? ' active' : '');
                btn.textContent = label;
                btn.onclick = () => {
                    if (mode === 'compare') setViewMode(layoutMode); // use auto-picked H/V
                    else setViewMode(mode);
                };
                modeCore.appendChild(btn);
            });
            strip.appendChild(modeCore);

            // When overlay is active, build the asset group and animate it sliding in
            if (normalised === 'overlay') {
                const loaded = assetOrder.filter(slot => mediaData[slot]);

                const assetGroup = document.createElement('div');
                // Render invisible but in-flow so we can measure its width before animating
                assetGroup.className = 'asset-group';

                loaded.forEach((slot, i) => {
                    const sep = document.createElement('span');
                    sep.className = 'strip-sep asset-sep';
                    sep.textContent = '¬∑';
                    assetGroup.appendChild(sep);

                    const layerEl = getLayer(slot);
                    const nameEl = layerEl ? layerEl.querySelector('.asset-name') : null;
                    const label = nameEl ? nameEl.textContent : slot;
                    const btn = document.createElement('button');
                    const isActive = assetOrder.indexOf(slot) === currentAssetIndex;
                    const posClass = (i === 0 ? ' first-asset' : '') + (i === loaded.length - 1 ? ' last-asset' : '');
                    btn.className = 'asset-btn' + (isActive ? ' active' : '') + posClass;
                    btn.textContent = label;
                    btn.onclick = () => switchToAsset(assetOrder.indexOf(slot));
                    assetGroup.appendChild(btn);
                });
                strip.appendChild(assetGroup);

                // Create (or reuse) the sliding underline bar
                let underline = document.getElementById('assetUnderline');
                if (!underline) {
                    underline = document.createElement('div');
                    underline.id = 'assetUnderline';
                }
                strip.appendChild(underline);

                // After layout: measure asset group width, set it as a CSS custom property
                // so the @keyframe animation slides mode-core left by exactly that amount.
                requestAnimationFrame(() => {
                    const groupW = assetGroup.offsetWidth;

                    // Tell the keyframe animation how far to slide
                    modeCore.style.setProperty('--asset-group-width', `${groupW}px`);
                    modeCore.classList.add('sliding');

                    // Snap underline into place (offsetLeft-based, immune to transforms)
                    underline.style.transition = 'none';
                    positionAssetUnderline();

                    // Trigger asset group reveal animation
                    assetGroup.classList.add('visible');

                    // Re-enable underline slide transition after it's been placed
                    requestAnimationFrame(() => {
                        underline.style.transition = '';
                    });
                });
            }
        }

        // Moves the sliding underline to sit beneath the currently active asset button.
        // Uses offsetLeft traversal (not getBoundingClientRect) so CSS transforms on
        // parent elements don't skew the measurement.
        function positionAssetUnderline() {
            const strip = document.getElementById('modeStrip');
            const underline = document.getElementById('assetUnderline');
            if (!strip || !underline) return;

            const activeBtn = strip.querySelector('.asset-btn.active');
            if (!activeBtn) { underline.classList.remove('visible'); return; }

            // Walk up offsetParent chain to sum offsetLeft relative to the strip
            let left = 0;
            let el = activeBtn;
            while (el && el !== strip) {
                left += el.offsetLeft;
                el = el.offsetParent;
            }

            // Size the underline to the text content, not the full padded button width,
            // then offset it to sit centered under the text (skipping the 8px padding).
            const paddingLeft = parseFloat(getComputedStyle(activeBtn).paddingLeft);
            const paddingRight = parseFloat(getComputedStyle(activeBtn).paddingRight);
            const textWidth = activeBtn.offsetWidth - paddingLeft - paddingRight;

            underline.style.left = (left + paddingLeft) + 'px';
            underline.style.width = textWidth + 'px';
            underline.classList.add('visible');
        }

        // Asset buttons are now inlined into the mode strip when overlay is active.
        // This function is kept as a no-op so existing call sites don't break.
        function updateAssetStrip() {
            document.getElementById('assetStrip').style.display = 'none';
        }

        // Updates the active class on inline asset buttons without rebuilding the strip,
        // then slides the underline to the newly active button.
        function refreshAssetButtons() {
            const strip = document.getElementById('modeStrip');
            if (!strip) return;
            const assetBtns = strip.querySelectorAll('.asset-btn');
            if (!assetBtns.length) return;

            // Re-sync .active class based on current assetOrder / currentAssetIndex
            const loaded = assetOrder.filter(slot => mediaData[slot]);
            assetBtns.forEach((btn, i) => {
                const slot = loaded[i];
                const isActive = slot && assetOrder.indexOf(slot) === currentAssetIndex;
                btn.classList.toggle('active', !!isActive);
            });

            // Slide underline to new position
            positionAssetUnderline();
        }

        // Update checkAllLoaded to show view mode buttons
        function checkAllLoaded() {
            const loadedCount = Object.values(mediaData).filter(m => m !== null).length;
            
            // Wait until all expected files are loaded before activating the view.
            // Firing early (e.g. at loadedCount=2 during a 3-file load) causes
            // setViewMode('horizontal') to hide the not-yet-loaded third layer,
            // resulting in a black screen when tripartite mode is set moments later.
            if (loadedCount < expectedFileCount) {
                return;
            }

            // Idempotency guard: checkAllLoaded() fires once per img.load/loadedmetadata
            // event, so with 3 images it fires 3 times once all are loaded.  Only the
            // first call should run the full activation; subsequent calls just reposition
            // so newly-decoded dimensions are reflected without destructive re-runs of
            // switchToAsset + setViewMode.
            // NOTE: we cannot check comparisonView.classList.contains('active') here
            // because clearAllMedia() removes that class before new files start loading.
            if (viewActivating) {
                positionLabelsToMediaDebounced();
                return;
            }

            // Need at least 2 files loaded (Edit A and Edit B minimum)
            if (loadedCount >= 2) {
                viewActivating = true; // prevent re-entry from subsequent img.load events
                
                // Hide quick start popup if showing
                document.getElementById('quickStartPopup').classList.remove('show');

                document.getElementById('comparisonView').classList.add('active');

                document.getElementById('resetBtn').style.display = 'block';

                // Show view mode buttons (initial state is overlay mode)
                // (updateViewModeButtons will set correct visibility based on asset count)

                // Show/hide audio source buttons based on what's loaded
                document.getElementById('audioOriginal').style.display = mediaData.original ? 'inline-block' : 'none';
                document.getElementById('audioEditA').style.display = mediaData.editA ? 'inline-block' : 'none';
                document.getElementById('audioEditB').style.display = mediaData.editB ? 'inline-block' : 'none';

                // Set initial audio source to first loaded video
                if (mediaData.original) {
                    selectAudioSource('original');
                } else if (mediaData.editA) {
                    selectAudioSource('editA');
                } else {
                    selectAudioSource('editB');
                }

                // Check for identical assets
                checkForIdenticalAssets();
                
                // Start with first loaded asset
                if (mediaData.original) {
                    switchToAsset(0); // Start with original
                } else if (mediaData.editA) {
                    switchToAsset(1); // Start with Edit A if no original
                } else {
                    switchToAsset(2); // Start with Edit B
                }

                // 2-asset mode: relabel assets and auto-pick layout by dominant dimension.
                // 3-asset mode: always tripartite.
                if (loadedCount === 2 && !mediaData.original) {
                    // Relabel: IMAGE A/B or VIDEO A/B (no "EDIT" label when there's no original)
                    const mediaType = (mediaData.editA?.type === 'video' || mediaData.editB?.type === 'video')
                        ? 'VIDEO' : 'IMAGE';
                    document.querySelector('#layerEditA .asset-name').textContent = mediaType + ' A';
                    document.querySelector('#layerEditB .asset-name').textContent = mediaType + ' B';

                    // Auto-pick layout: landscape ‚Üí vertical stack, portrait ‚Üí side-by-side
                    const sample = mediaData.editA || mediaData.editB;
                    const isLandscape = (sample.w || 1) >= (sample.h || 1);
                    setViewMode(isLandscape ? 'vertical' : 'horizontal');
                } else {
                    setViewMode(loadedCount === 3 ? 'tripartite' : 'horizontal');
                }

                // Show video controls if any videos
                if (hasVideos) {
                    document.getElementById('videoControls').classList.add('active');
                }
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('muteBtn');

            getAllVideos().forEach(v => {
                v.muted = isMuted;
            });

            btn.textContent = isMuted ? 'üîá' : 'üîä';
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // L key opens file picker ‚Äî works at any time
            if (e.key === 'l' || e.key === 'L') {
                e.preventDefault();
                document.getElementById('multiFileInput').click();
                return;
            }

            // K key toggles shortcuts panel ‚Äî works at any time
            if (e.key === 'k' || e.key === 'K') {
                e.preventDefault();
                toggleShortcutsPanel();
                return;
            }

            // Only work if comparison view is active
            if (!document.getElementById('comparisonView').classList.contains('active')) {
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                // Move to previous non-empty slot
                let nextIndex = (currentAssetIndex - 1 + assetOrder.length) % assetOrder.length;
                let attempts = 0;
                while (!mediaData[assetOrder[nextIndex]] && attempts < assetOrder.length) {
                    nextIndex = (nextIndex - 1 + assetOrder.length) % assetOrder.length;
                    attempts++;
                }
                if (mediaData[assetOrder[nextIndex]]) {
                    switchToAsset(nextIndex);
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                // Move to next non-empty slot
                let nextIndex = (currentAssetIndex + 1) % assetOrder.length;
                let attempts = 0;
                while (!mediaData[assetOrder[nextIndex]] && attempts < assetOrder.length) {
                    nextIndex = (nextIndex + 1) % assetOrder.length;
                    attempts++;
                }
                if (mediaData[assetOrder[nextIndex]]) {
                    switchToAsset(nextIndex);
                }
            } else if (e.key === 'f' || e.key === 'F') {
                // F toggles browser fullscreen (hides browser chrome)
                e.preventDefault();
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(() => {});
                } else {
                    document.exitFullscreen();
                }
            } else if (e.key === '+' || e.key === '=') {
                // Zoom in (overlay mode only ‚Äî always available, no mode gate)
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                // Zoom out (overlay mode only)
                e.preventDefault();
                zoomOut();
            } else if (e.key === '0') {
                e.preventDefault();
                resetFitZoom();
            } else if (e.key === '1') {
                // Snap to 100% actual pixels
                e.preventDefault();
                if (!isSplitMode) {
                    // Overlay: snap to 100% actual pixels, reset pan
                    zoomLevel = 1;
                    panOffsetX = 0;
                    panOffsetY = 0;
                    applyZoom();
                } else {
                    // Split modes: toggle between fit-to-panel and 100%-anchor (smallest asset at native pixels).
                    // Reset any step zoom so the 100%-anchor size is the clean baseline.
                    splitZoomLevel = splitZoomLevel === 1 ? null : 1;
                    splitStepZoom = 1.0;
                    document.body.classList.toggle('zoom-100', splitZoomLevel === 1);
                    positionLabelsToMedia();
                }
            } else if (e.key === ' ') {
                // Spacebar toggles play/pause for videos
                e.preventDefault();
                togglePlayPause();
            } else if (e.key === 'r' || e.key === 'R') {
                // R key restarts from beginning
                e.preventDefault();
                restartAllVideos();
            } else if (e.key === 'm' || e.key === 'M') {
                // M key toggles mute
                e.preventDefault();
                toggleMute();
            } else if (e.key === 'o' || e.key === 'O') {
                // O key toggles overlay <-> split (tripartite for 3 assets, auto-layout for 2).
                e.preventDefault();
                const allThreeLoaded = Object.values(mediaData).filter(m => m !== null).length === 3;
                if (isSplitMode) {
                    setViewMode('overlay');
                } else if (allThreeLoaded) {
                    setViewMode('tripartite');
                } else {
                    setViewMode(layoutMode);
                }
            } else if (e.key === 'c' || e.key === 'C') {
                // C key toggles compare mode depending on asset count.
                e.preventDefault();
                const allThreeLoaded = Object.values(mediaData).filter(m => m !== null).length === 3;
                if (allThreeLoaded) {
                    // 3-asset cycle: overlay <-> tripartite
                    if (!isSplitMode) {
                        setViewMode('tripartite');
                    } else {
                        setViewMode('overlay');
                    }
                } else {
                    // 2-asset: toggle overlay <-> the auto-picked split layout
                    if (!isSplitMode) {
                        setViewMode(layoutMode); // return to auto-picked horizontal or vertical
                    } else {
                        setViewMode('overlay');
                    }
                }
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            setupPanHandlers(); // pan always available in overlay mode
        });

        function toggleShortcutsPanel() {
            document.getElementById('shortcutsPanel').classList.toggle('open');
            document.getElementById('shortcutsBackdrop').classList.toggle('open');
        }

        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const icon = document.getElementById('toggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

    </script>

    <div class="shortcuts-backdrop" id="shortcutsBackdrop"></div>
    <div class="shortcuts-panel" id="shortcutsPanel">
        <div class="shortcuts-panel-header">
            <span>Hotkeys</span>
            <button onclick="toggleShortcutsPanel()">‚úï</button>
        </div>
        <div class="shortcuts-list">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>‚Üê</kbd> <kbd>‚Üí</kbd></span><span class="shortcut-desc">Switch asset</span></div>
            <hr class="shortcut-divider">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>O</kbd></span><span class="shortcut-desc">Toggle overlay mode</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>C</kbd></span><span class="shortcut-desc">Toggle compare mode</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>F</kbd></span><span class="shortcut-desc">Browser fullscreen</span></div>
            <hr class="shortcut-divider">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>+</kbd> <kbd>-</kbd></span><span class="shortcut-desc">Zoom in / out</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>0</kbd></span><span class="shortcut-desc">Zoom to fit</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>1</kbd></span><span class="shortcut-desc">Zoom to 100%</span></div>
            <hr class="shortcut-divider">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>Space</kbd></span><span class="shortcut-desc">Play / Pause</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>R</kbd></span><span class="shortcut-desc">Restart</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>M</kbd></span><span class="shortcut-desc">Mute</span></div>
            <hr class="shortcut-divider">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>L</kbd></span><span class="shortcut-desc">Load files</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>K</kbd></span><span class="shortcut-desc">Toggle this panel</span></div>
        </div>
    </div>

</body>
</html>
