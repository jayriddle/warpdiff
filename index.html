<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpDiff</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: rgb(32, 32, 32);
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 8px 20px;
            background: #2a2a2a;
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
        }

        .position-toggle {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 10px;
        }

        .position-toggle:hover {
            background: #666;
        }

        .help-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .help-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
        }

        [data-help]:hover .help-tooltip {
            opacity: 1;
        }

        button[data-help] {
            position: relative;
        }

        .help-text-area {
            grid-column: span 2;
            background: #2a2a2a;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 12px;
            color: #999;
            line-height: 1.5;
            display: flex;
            align-items: center;
            min-height: 60px;
        }

        .help-text-content {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .help-text-content.show {
            opacity: 1;
        }

        .keyboard-hints {
            font-size: 11px;
            color: #999;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            margin: 0 2px;
            font-size: 10px;
        }

        .video-progress-container {
            flex: 1;
            height: 8px;
            background: rgba(160, 160, 160, 0.3);
            cursor: pointer;
            border-radius: 4px;
            overflow: hidden;
            user-select: none;
        }

        .video-progress-container:active {
            cursor: grabbing;
        }

        .video-progress-bar {
            height: 100%;
            background: rgb(160, 160, 160);
            width: 0%;
        }

        .video-timecode:hover {
            color: #fff;
        }

            display: inline-flex;
            align-items: center;
            gap: 4px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .audio-source-selector button.active {
            background: rgb(160, 160, 160);
            color: #000;
            border-color: rgb(160, 160, 160);
        }

        .audio-source-selector button.muted {
            background: #2a2a2a;
            color: #666;
            text-decoration: line-through;
            border: 2px solid #ff4444;
            opacity: 0.6;
        }

        .audio-source-selector button.muted .audio-mute-icon {
            color: #ff4444;
        }

        .audio-source-selector button:hover {
            background: #666;
        }

        .audio-source-selector button.active:hover {
            background: rgb(180, 180, 180);
        }

        .audio-source-selector button.muted:hover {
            background: #333;
            opacity: 0.8;
        }

        .audio-mute-icon {
            font-size: 12px;
            cursor: pointer;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(160, 160, 160, 0.3);
            outline: none;
            border-radius: 2px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            background: rgb(160, 160, 160);
            cursor: pointer;
            border-radius: 50%;
        }

        .volume-slider::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: rgb(160, 160, 160);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .audio-source-selector {
            display: flex;
            gap: 4px;
        }

        .audio-source-selector button {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .video-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 10;
            flex-direction: column;
            align-items: center;
            min-width: 300px;
        }

        .video-controls.active {
            display: flex;
        }



        .quick-start-btn {
            padding: 4px 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 15px;
            position: relative;
        }

        .quick-start-btn:hover {
            background: #666;
        }

        .quick-start-popup {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: #2a2a2a;
            border: 2px solid rgb(160, 160, 160);
            border-radius: 8px;
            padding: 20px 30px;
            z-index: 1000;
            width: 450px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: none;
        }

        .quick-start-popup.show {
            display: block;
        }

        .quick-start-overlay {
            display: none;
        }

        .quick-start-close {
            float: right;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 11px;
        }

        .comparison-view {
            flex: 1;
            position: relative;
            background: #000;
            display: none;
            min-height: 0; /* Allow flex child to shrink below content size */
        }

        .comparison-view.active {
            display: flex;
            flex-direction: column;
        }

        .overlay-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
        }

        .overlay-layer.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Media container: fills the layer, positioning context for JS-placed children */
        .media-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* video-wrapper: JS sets top/left/width/height to exact rendered media bounds in all modes */
        .video-wrapper {
            position: absolute;
        }

        /* Media fills the wrapper exactly ‚Äî object-fit:contain handled by JS sizing the wrapper */
        .video-wrapper img,
        .video-wrapper video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Info bar: JS positions it per mode (above video in overlay/horizontal, left in vertical) */
        .media-container > .asset-info-bar {
            position: absolute;
        }

        /* In overlay mode, only show info bar and zoom for the active layer */
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer:not(.active) .asset-info-bar,
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer:not(.active) .split-zoom-indicator {
            display: none;
        }

        /* Info bars always visible in split modes */
        body.side-by-side .asset-info-bar,
        body.vertical-stack .asset-info-bar,
        body.tripartite .asset-info-bar {
            display: flex;
        }

        body.side-by-side .overlay-layer {
            position: relative;
            width: 50%;
            display: inline-block;
            vertical-align: top;
            cursor: grab;
        }

        body.side-by-side .overlay-layer.active,
        body.side-by-side .overlay-layer:not(.active),
        body.vertical-stack .overlay-layer.active,
        body.vertical-stack .overlay-layer:not(.active),
        body.tripartite .overlay-layer.active,
        body.tripartite .overlay-layer:not(.active) {
            opacity: 1;
            pointer-events: auto;
        }

        /* Horizontal split: layer height */
        body.side-by-side .overlay-layer {
            height: calc(100vh - 50px);
        }

        body.side-by-side .overlay-container {
            white-space: nowrap;
            overflow-x: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0;
        }

        /* Vertical stacking mode */
        body.vertical-stack .overlay-layer {
            position: relative !important;
            width: 100%;
            height: calc((100vh - 80px) / 3);
            display: block;
            cursor: grab;
            margin-bottom: 10px;
            overflow: hidden;
        }

        /* 2-asset vertical: divide by 2 not 3 */
        body.vertical-stack.two-asset .overlay-layer {
            height: calc((100vh - 70px) / 2);
        }

        body.vertical-stack .overlay-container {
            white-space: normal;
            overflow-y: visible;
            display: block;
            padding-bottom: 20px;
        }

        /* Tripartite: Original left-half, Edit A top-right, Edit B bottom-right */
        body.tripartite .overlay-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            height: calc(100vh - 50px);
            overflow: hidden;
            align-items: stretch;
            justify-items: stretch;
        }

        body.tripartite .overlay-layer {
            position: relative !important;
            width: 100% !important;
            height: 100% !important;
            display: block !important;
            align-items: unset !important;
            justify-content: unset !important;
            cursor: grab;
            overflow: hidden;
        }

        body.tripartite .media-container {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
        }

        /* In all split modes the video-wrapper is JS-sized to exact rendered bounds.
           The media element must fill it 100%. Override the general overlay-layer rule
           (width:auto; height:auto) which has equal specificity but appears later. */
        body.side-by-side .overlay-layer img,
        body.side-by-side .overlay-layer video,
        body.vertical-stack .overlay-layer img,
        body.vertical-stack .overlay-layer video,
        body.tripartite .overlay-layer img,
        body.tripartite .overlay-layer video {
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
            object-fit: contain;
        }

        body.tripartite #layerOriginal {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        body.tripartite #layerEditA {
            grid-column: 2;
            grid-row: 1;
        }

        body.tripartite #layerEditB {
            grid-column: 2;
            grid-row: 2;
        }

        body.tripartite .asset-info-bar {
            display: flex;
        }

        body.tripartite .overlay-layer.active-audio .asset-info-bar {
            border: 2px solid #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }

        body.tripartite .overlay-layer.active-audio .asset-info-bar .asset-name {
            color: #28a745;
        }

        /* fit-cover toggles */
        body.side-by-side.fit-cover .video-wrapper img,
        body.side-by-side.fit-cover .video-wrapper video,
        body.vertical-stack.fit-cover .video-wrapper img,
        body.vertical-stack.fit-cover .video-wrapper video,
        body.tripartite.fit-cover .video-wrapper img,
        body.tripartite.fit-cover .video-wrapper video {
            object-fit: cover;
        }

        /* Zoom level indicator - overlays bottom right corner of media */
        .split-zoom-indicator {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.85);
            padding: 4px 8px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 3px;
            pointer-events: none;
            z-index: 10;
            color: rgb(160, 160, 160);
            font-family: monospace;
            display: block; /* Always show in all modes */
        }

        /* Asset info bar styling */
        .asset-info-bar {
            display: none; /* Hidden by default in overlay; shown in split modes and active overlay layer */
            flex-direction: row;
            align-items: center;
            gap: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            font-size: 11px;
            color: #a0a0a0;
            border-radius: 3px;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
        }

        .asset-info-bar .asset-name {
            font-weight: bold;
            color: #ffffff;
        }

        /* Active asset indicator - show and highlight in overlay mode only */
        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer.active .asset-info-bar {
            display: flex;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.2);
        }

        body:not(.side-by-side):not(.vertical-stack):not(.tripartite) .overlay-layer.active .asset-info-bar .asset-name {
            color: #007bff;
        }

        /* Active audio indicator for split views - shows which audio is playing */
        body.side-by-side .overlay-layer.active-audio .asset-info-bar,
        body.vertical-stack .overlay-layer.active-audio .asset-info-bar {
            border: 2px solid #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }

        body.side-by-side .overlay-layer.active-audio .asset-info-bar .asset-name,
        body.vertical-stack .overlay-layer.active-audio .asset-info-bar .asset-name {
            color: #28a745;
        }

        /* Drag and drop styling */
        .overlay-layer.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .overlay-layer.drag-over {
            border: 3px solid rgb(160, 160, 160);
        }

        .layout-controls {
            display: none !important;
        }

        .overlay-layer img,
        .overlay-layer video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            width: auto;
            height: auto;
        }

        /* Keyboard shortcuts slide-in panel */
        .shortcuts-panel {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: 240px;
            background: #1a1a1a;
            border-left: 1px solid #333;
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .shortcuts-panel.open {
            transform: translateX(0);
        }

        .shortcuts-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            background: #222;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .shortcuts-panel-header span {
            font-size: 13px;
            font-weight: 600;
            color: #ccc;
        }

        .shortcuts-panel-header button {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 4px;
            line-height: 1;
            border-radius: 3px;
        }

        .shortcuts-panel-header button:hover {
            background: #333;
            color: #ccc;
        }

        .shortcuts-list {
            margin: 0;
            padding: 8px 14px;
            overflow-y: auto;
            flex: 1;
        }

        .shortcut-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 6px 0;
        }

        .shortcut-key {
            flex-shrink: 0;
            min-width: 70px;
            color: #ccc;
            font-size: 14px;
            white-space: nowrap;
        }

        .shortcut-desc {
            color: #888;
            font-size: 14px;
        }

        .shortcuts-list kbd {
            background: #333;
            padding: 2px 7px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
            color: #bbb;
            margin: 0 1px;
            border: 1px solid #444;
        }

        body.fullscreen {
            background: #000;
        }

        body.fullscreen .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        body.fullscreen .comparison-view {
            display: block;
        }

        body.fullscreen .comparison-view.active {
            display: flex;
            flex-direction: column;
        }

        body.fullscreen .overlay-layer img {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            user-select: none;
            -webkit-user-drag: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body.fullscreen .overlay-layer video {
            user-select: none;
            -webkit-user-drag: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body.fullscreen .overlay-container {
            user-select: none;
        }


        .video-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 16px;
            border-radius: 6px;
            z-index: 10;
            display: none;
            min-width: 600px;
            max-width: 90vw;
        }

        .video-controls.active {
            display: block;
        }

        /* In split/stack views, position controls at bottom of viewport */
        body.side-by-side .video-controls,
        body.vertical-stack .video-controls,
        body.tripartite .video-controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 90vw;
            z-index: 100;
        }

        .video-controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .video-timecode,
        .video-duration {
            font-family: monospace;
            font-size: 12px;
            font-weight: 600;
            color: rgb(160, 160, 160);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .video-timecode:hover,
        .video-duration:hover {
            color: #fff;
        }

        .volume-icon {
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .volume-icon:hover {
            opacity: 0.8;
        }

        .identical-warning {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 193, 7, 0.95);
            color: #000;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }

        .identical-warning.show {
            display: block;
        }

        body.fullscreen .overlay-container {
            cursor: grab;
            overflow: hidden;
        }

        body.fullscreen .overlay-container.panning {
            cursor: grabbing;
        }

        body.fullscreen .overlay-layer img,
        body.fullscreen .overlay-layer video {
            position: relative;
            transition: none;
        }

        /* Inspect mode: hide non-active layers regardless of which mode we came from.
           Tripartite normally forces all layers to opacity:1, so we need !important here. */
        body.fullscreen .overlay-layer:not(.active) {
            opacity: 0 !important;
            pointer-events: none !important;
        }


        /* Inspect mode: hide info bar in overlay and tripartite (not in true split modes
           where each wrapper is anchored in its own cell). */
        body.fullscreen:not(.side-by-side):not(.vertical-stack) .overlay-layer .asset-info-bar {
            display: none !important;
        }

        .pan-hint {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 7px 18px;
            border-radius: 6px;
            font-size: 12px;
            color: #aaa;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .pan-hint.visible {
            opacity: 1;
        }

        .zoom-indicator {
            display: none; /* removed ‚Äî split-zoom-indicator on the image is sufficient */
        }

        .inspect-mode-badge {
            display: none;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.08em;
            color: #f0a500;
            background: rgba(240, 165, 0, 0.15);
            border: 1px solid rgba(240, 165, 0, 0.4);
            border-radius: 4px;
            padding: 3px 8px;
            margin-left: auto;
            align-self: center;
        }

        body.fullscreen .inspect-mode-badge {
            display: flex;
            align-items: center;
        }

        .instructions {
            padding: 12px 20px;
            background: #2a2a2a;
            border-radius: 4px;
            margin: 10px 20px;
            font-size: 12px;
            line-height: 1.6;
        }

        .instructions h2 {
            font-size: 13px;
            margin-bottom: 8px;
            color: rgb(160, 160, 160);
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .instructions p {
            margin-top: 8px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="position: relative;">
                <span style="font-size: 16px; font-weight: 600;">WarpDiff</span>
                <button class="quick-start-btn" onclick="toggleQuickStart()">Quick Start</button>
                
                <!-- Quick Start Popup -->
                <div class="quick-start-popup" id="quickStartPopup">
                    <button class="quick-start-close" onclick="toggleQuickStart()">Close</button>
                    <h2 style="margin-top: 0; color: rgb(160, 160, 160);">Quick Start Guide</h2>
                    <ol style="line-height: 1.8;">
                        <li>Right-click save files from in-house tool in order: <strong>&lt;Original, A, B&gt;</strong></li>
                        <li><strong>Select 2 or 3 files</strong> (Cmd+click) and drag anywhere, or press <kbd>L</kbd> to open the file picker
                            <ul style="margin-top: 5px; font-size: 11px; color: #999;">
                                <li><strong>2 files:</strong> Edit A vs Edit B (no original)</li>
                                <li><strong>3 files:</strong> Original vs Edit A vs Edit B</li>
                            </ul>
                        </li>
                        <li>Tool auto-sorts by save time and loads into correct slots</li>
                        <li>Press <kbd>F</kbd> for fullscreen, use <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> to compare</li>
                        <li>Press <kbd>+</kbd> <kbd>-</kbd> to zoom in/out</li>
                        <li>Press <kbd>Space</kbd> to play/pause videos</li>
                        <li>Press <kbd>K</kbd> to see all keyboard shortcuts</li>
                    </ol>
                    <p style="margin-top: 15px; font-size: 11px; color: #999;">
                        <em>Tip: Files are automatically sorted by modification time. Arrow keys skip empty slots.</em>
                    </p>
                </div>
            </div>
            <div>
                <button class="position-toggle" onclick="document.getElementById('multiFileInput').click()" id="loadBtn" data-help="Load 2‚Äì3 files to compare (or press L)">
                    Load
                    <div class="help-tooltip">Select 2‚Äì3 files to compare (auto-sorts by save time). Shortcut: L</div>
                </button>
                <input type="file" id="multiFileInput" accept="image/*,video/*" multiple onchange="handleMultiFileLoad(event)" style="display: none;">
                <button class="position-toggle" onclick="setViewMode('overlay')" id="overlayViewBtn" data-help="Single asset view with arrow key switching" style="display: none;">
                    Overlay
                    <div class="help-tooltip">Single asset view</div>
                </button>
                <button class="position-toggle" onclick="setViewMode('horizontal')" id="horizontalViewBtn" data-help="Side-by-side horizontal comparison" style="display: none;">
                    Horizontal
                    <div class="help-tooltip">Side-by-side view</div>
                </button>
                <button class="position-toggle" onclick="setViewMode('vertical')" id="verticalViewBtn" data-help="Vertically stacked comparison" style="display: none;">
                    Vertical
                    <div class="help-tooltip">Stacked view</div>
                </button>
                <button class="position-toggle" onclick="setViewMode('tripartite')" id="tripartiteViewBtn" data-help="Original left, Edit A/B stacked right (3 assets)" style="display: none;">
                    Tripartite
                    <div class="help-tooltip">Original left, Edits stacked right</div>
                </button>

            </div>
            <div>
                <button class="position-toggle" onclick="resetAll()" style="display: none;" id="resetBtn" data-help="Clear all assets and start over">
                    Reset All
                    <div class="help-tooltip">Clear all assets and start over</div>
                </button>
            </div>
            <div id="inspectModeBadge" class="inspect-mode-badge">INSPECT</div>
        </div>

        <div class="comparison-view" id="comparisonView">
            <div class="overlay-container" id="overlayContainer">
                <!-- Layout controls for side-by-side mode -->
                <div class="layout-controls" id="layoutControls">
                    <button onclick="setViewMode('horizontal')" id="horizontalBtn" class="active">Horizontal</button>
                    <button onclick="setViewMode('vertical')" id="verticalBtn">Vertical</button>
                    <span style="color: #999; font-size: 11px; margin: 0 5px;">Drag to reorder</span>
                </div>
                
                <div class="overlay-layer" id="layerOriginal">
                    <div class="split-zoom-indicator" id="zoomOriginal">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">ORIGINAL</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                <div class="overlay-layer" id="layerEditA">
                    <div class="split-zoom-indicator" id="zoomEditA">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">EDIT A</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                <div class="overlay-layer" id="layerEditB">
                    <div class="split-zoom-indicator" id="zoomEditB">1.0√ó</div>
                    <div class="asset-info-bar">
                        <span class="asset-name">EDIT B</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    </div>
                </div>
                
                <div class="identical-warning" id="identicalWarning">
                    ‚ö†Ô∏è Identical Assets Detected
                </div>
                
                <div class="zoom-indicator" id="zoomIndicator">
                    2.0√ó
                </div>

                <div class="pan-hint">
                    Click and drag to pan &nbsp;¬∑&nbsp; Esc to exit
                </div>

                <div class="video-controls" id="videoControls">
                    <div class="video-controls-row">
                        <span class="video-timecode" id="videoTimecode" onclick="toggleTimecodeMode()" title="Click to toggle time/frame display">0:00:00</span>
                        <div class="video-progress-container" id="videoProgressContainer">
                            <div class="video-progress-bar" id="videoProgressBar"></div>
                        </div>
                        <span class="video-duration" id="videoDuration">0:00:00</span>
                        <div class="volume-control">
                            <span class="volume-icon" onclick="toggleMute()" id="muteBtn" title="Click to mute/unmute">üîä</span>
                            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" oninput="setVolume(this.value)">
                        </div>
                        <div class="audio-source-selector" id="audioSourceSelector">
                            <button onclick="selectAudioSource('original')" id="audioOriginal" class="active" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('original')">üîä</span>
                                O
                            </button>
                            <button onclick="selectAudioSource('editA')" id="audioEditA" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('editA')">üîä</span>
                                A
                            </button>
                            <button onclick="selectAudioSource('editB')" id="audioEditB" title="Click to select audio source">
                                <span class="audio-mute-icon" onclick="event.stopPropagation(); toggleAudioMute('editB')">üîä</span>
                                B
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const mediaData = {
            original: null,
            editA: null,
            editB: null
        };

        const assetOrder = ['original', 'editA', 'editB'];
        let currentAssetIndex = 0;
        let isFullscreen = false;
        let hasVideos = false;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panOffsetX = 0;
        let panOffsetY = 0;

        let zoomLevel = 1; // Default 1x zoom (actual size/fit)
        let timecodeMode = 'time'; // 'time' or 'frames'
        let videoFrameRates = {}; // Store framerate for each video
        let splitViewFitMode = 'contain'; // 'contain' (fit, no crop - default) or 'cover' (fill, crop)
        // Undo/Redo state management
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STATES = 20;
        
        // Smooth multiplicative zoom: each step multiplies/divides by ZOOM_STEP.
        // ‚àö2 ‚âà 1.414 gives a classic "one stop" doubling every two steps.
        const ZOOM_STEP = Math.SQRT2;
        const ZOOM_MIN = 0.05;  // 5% ‚Äî effectively a hard floor
        const ZOOM_MAX = 32;    // 3200% ‚Äî hard ceiling
        let fitZoom = 1; // Fit-to-viewport zoom, computed when entering inspect mode

        // Debounced positionLabelsToMedia ‚Äî collapses rapid per-asset load events into one call
        // so normalization always runs after all loaded slots have reported their dimensions.
        let _positionDebounceTimer = null;
        function positionLabelsToMediaDebounced() {
            clearTimeout(_positionDebounceTimer);
            _positionDebounceTimer = setTimeout(positionLabelsToMedia, 150);
        }

        // Setup drag and drop ‚Äî listen on the whole page
        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files);
                handleMultipleFiles(files);
            }, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFileLoad(slot, event) {
            const file = event.target.files[0];
            if (file) {
                loadFile(slot, file);
            }
        }

        function handleMultiFileLoad(event) {
            const files = Array.from(event.target.files);
            handleMultipleFiles(files);
        }

        function handleMultipleFiles(files) {
            // Filter for images and videos only
            const mediaFiles = files.filter(f =>
                f.type.startsWith('image/') || f.type.startsWith('video/')
            );

            if (mediaFiles.length !== 2 && mediaFiles.length !== 3) {
                alert(`Please select 2 or 3 media files.\nYou selected ${mediaFiles.length} media file(s).\n\n2 files = Edit A vs Edit B (no original)\n3 files = Original vs Edit A vs Edit B`);
                return;
            }

            // Always start from a clean slate so stale state from a previous load
            // (e.g., a mediaData.original left over from a prior 3-file session) never
            // bleeds into the new load. This mirrors resetAll() but without the dialog.
            clearAllMedia();

            // Sort by lastModified timestamp (oldest to newest)
            const sortedFiles = mediaFiles.sort((a, b) => a.lastModified - b.lastModified);

            if (sortedFiles.length === 3) {
                // 3 files: oldest -> original, middle -> editA, newest -> editB
                loadFile('original', sortedFiles[0]);
                loadFile('editA', sortedFiles[1]);
                loadFile('editB', sortedFiles[2]);

                setTimeout(() => {
                    const msg = `‚úì Auto-loaded 3 files by save time:\n` +
                               `  ORIGINAL: ${sortedFiles[0].name}\n` +
                               `  EDIT A: ${sortedFiles[1].name}\n` +
                               `  EDIT B: ${sortedFiles[2].name}`;
                    console.log(msg);
                }, 500);
            } else {
                // 2 files: oldest -> editA, newest -> editB (no original)
                loadFile('editA', sortedFiles[0]);
                loadFile('editB', sortedFiles[1]);

                setTimeout(() => {
                    const msg = `‚úì Auto-loaded 2 files (no original):\n` +
                               `  EDIT A: ${sortedFiles[0].name}\n` +
                               `  EDIT B: ${sortedFiles[1].name}`;
                    console.log(msg);
                }, 500);
            }
        }

        function loadFile(slot, file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const dataUrl = e.target.result;
                const isVideo = file.type.startsWith('video/');
                
                mediaData[slot] = {
                    type: isVideo ? 'video' : 'image',
                    src: dataUrl,
                    name: file.name
                };

                // Load into overlay layer
                const layer = document.getElementById(`layer${slot.charAt(0).toUpperCase() + slot.slice(1)}`);

                // Remove old media container but preserve info bars and zoom indicators at layer level
                const oldContainer = layer.querySelector('.media-container');
                if (oldContainer) {
                    oldContainer.remove();
                }

                // Create media container to hold the actual image/video
                const mediaContainer = document.createElement('div');
                mediaContainer.className = 'media-container';

                if (isVideo) {
                    console.log(`Creating video element for ${slot}`);
                    const video = document.createElement('video');
                    video.src = dataUrl;
                    video.controls = false;
                    video.volume = 1.0;

                    video.addEventListener('loadedmetadata', function() {
                        console.log(`${slot} loadedmetadata event fired`);
                        if (mediaData[slot]) { mediaData[slot].w = video.videoWidth; mediaData[slot].h = video.videoHeight; }
                        updateResolutionDisplay(slot, video.videoWidth, video.videoHeight);
                        updateDurationDisplay(slot, video.duration);

                        console.log(`Video ${slot} metadata loaded: ${video.videoWidth}x${video.videoHeight}`);

                        // Setup video handlers
                        setupVideoHandlers(video, slot);

                        // Position labels after video loads ‚Äî debounced so all slots
                        // are measured together once rapid successive loads settle.
                        positionLabelsToMediaDebounced();

                        console.log(`Video ${slot} fully loaded and ready`);
                    });

                    console.log(`Appending video to container for ${slot}`);
                    mediaContainer.appendChild(video);
                    hasVideos = true;
                    console.log(`hasVideos set to true`);
                } else {
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.addEventListener('load', async function() {
                        // Wait for image to be fully decoded before getting dimensions
                        try {
                            await img.decode();
                        } catch (e) {
                            console.warn('Image decode error:', e);
                        }

                        if (mediaData[slot]) { mediaData[slot].w = img.naturalWidth; mediaData[slot].h = img.naturalHeight; }
                        updateResolutionDisplay(slot, img.naturalWidth, img.naturalHeight);
                        updateSplitViewZoomIndicators();
                        // Debounced so all slots are measured together once rapid successive loads settle.
                        positionLabelsToMediaDebounced();
                    });
                    mediaContainer.appendChild(img);
                }

                // Find or create info bar and zoom indicator, then add to media container
                let infoBar = layer.querySelector('.asset-info-bar');
                let zoomIndicator = layer.querySelector('.split-zoom-indicator');

                // If they don't exist (shouldn't happen but safety check), create them
                if (!infoBar) {
                    infoBar = document.createElement('div');
                    infoBar.className = 'asset-info-bar';
                    const slotLabel = slot === 'original' ? 'ORIGINAL' : slot === 'editA' ? 'EDIT A' : 'EDIT B';
                    infoBar.innerHTML = `
                        <span class="asset-name">${slotLabel}</span>
                        <span class="asset-resolution">-</span>
                        <span class="asset-aspect">-</span>
                        <span class="asset-duration">-</span>
                    `;
                }

                if (!zoomIndicator) {
                    zoomIndicator = document.createElement('div');
                    zoomIndicator.className = 'split-zoom-indicator';
                    zoomIndicator.id = `zoom${slot.charAt(0).toUpperCase() + slot.slice(1)}`;
                    zoomIndicator.textContent = '1.0√ó';
                }

                // Build the asset structure:
                //   media-container (position:relative, fills layer)
                //     ‚îú‚îÄ‚îÄ asset-info-bar  ‚Üê JS-positioned per mode
                //     ‚îî‚îÄ‚îÄ video-wrapper   ‚Üê JS-sized to exact rendered video bounds
                //           ‚îú‚îÄ‚îÄ video/img
                //           ‚îî‚îÄ‚îÄ split-zoom-indicator  ‚Üê always bottom-right of wrapper

                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-wrapper';

                // Move the media element into the wrapper
                const mediaEl = mediaContainer.querySelector('img, video');
                if (mediaEl) videoWrapper.appendChild(mediaEl);

                // Zoom indicator lives inside the wrapper ‚Äî always at bottom-right of video bounds
                videoWrapper.appendChild(zoomIndicator);

                // Info bar is a sibling of video-wrapper ‚Äî JS positions it per mode
                mediaContainer.appendChild(infoBar);
                mediaContainer.appendChild(videoWrapper);

                layer.appendChild(mediaContainer);

                checkAllLoaded();
            };

            reader.readAsDataURL(file);
        }

        function updateResolutionDisplay(slot, width, height) {
            const resolution = `${width}√ó${height}`;
            const ratio = width / height;
            const standardRatios = [
                { value: 16/9, label: '16:9' },
                { value: 9/16, label: '9:16' },
                { value: 4/3, label: '4:3' },
                { value: 3/4, label: '3:4' },
                { value: 3/2, label: '3:2' },
                { value: 2/3, label: '2:3' },
                { value: 1.85, label: '1.85:1' },
                { value: 2.39, label: '2.39:1' },
                { value: 21/9, label: '21:9' },
                { value: 1, label: '1:1' }
            ];

            // Find closest standard ratio (within 1% tolerance)
            let aspectRatio = `${ratio.toFixed(2)}:1`;
            for (const std of standardRatios) {
                if (Math.abs(ratio - std.value) / std.value < 0.01) {
                    aspectRatio = std.label;
                    break;
                }
            }

            updateAssetInfoBar(slot, { resolution, aspectRatio });
        }

        function updateDurationDisplay(slot, duration) {
            if (!duration) return;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            updateAssetInfoBar(slot, { duration: durationStr });
        }

        function updateAssetInfoBar(slot, data) {
            const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
            const layer = document.getElementById(`layer${slotName}`);
            if (!layer) return;

            const infoBar = layer.querySelector('.asset-info-bar');
            if (!infoBar) return;

            // Update resolution
            if (data.resolution) {
                const resElement = infoBar.querySelector('.asset-resolution');
                if (resElement) resElement.textContent = data.resolution;
            }

            // Update aspect ratio
            if (data.aspectRatio) {
                const aspectElement = infoBar.querySelector('.asset-aspect');
                if (aspectElement) aspectElement.textContent = data.aspectRatio;
            }

            // Update duration
            if (data.duration) {
                const durationElement = infoBar.querySelector('.asset-duration');
                if (durationElement) durationElement.textContent = data.duration;
            }
        }

        // Global progress update loop (shared across all videos)
        let globalAnimationId = null;
        function startProgressUpdateLoop() {
            // Only start if not already running
            if (globalAnimationId !== null) return;

            function updateLoop() {
                // Find the video that should drive the progress bar
                let primaryVideo = null;

                if (!isSideBySide) {
                    // In overlay mode, use the active layer's video
                    const activeLayer = document.querySelector('.overlay-layer.active');
                    if (activeLayer) {
                        primaryVideo = activeLayer.querySelector('video');
                    }
                } else {
                    // In split view, use the first video
                    primaryVideo = document.querySelector('.overlay-layer video');
                }

                // Update progress if we have a primary video and it's playing
                if (primaryVideo && !primaryVideo.paused) {
                    updateVideoProgress(primaryVideo);
                }

                // Always continue the loop
                globalAnimationId = requestAnimationFrame(updateLoop);
            }

            updateLoop();
        }

        function stopProgressUpdateLoop() {
            if (globalAnimationId !== null) {
                cancelAnimationFrame(globalAnimationId);
                globalAnimationId = null;
            }
        }

        function setupVideoHandlers(video, slot) {
            // Enable native looping
            video.loop = true;
            
            // Detect framerate from video metadata
            video.addEventListener('loadedmetadata', function() {
                videoFrameRates[video.src] = 30;
            });
            
            video.addEventListener('play', function() {
                // Sync all videos when any video plays
                document.querySelectorAll('video').forEach(v => {
                    if (v !== video) {
                        v.play();
                        if (Math.abs(v.currentTime - video.currentTime) > 0.5) {
                            v.currentTime = video.currentTime;
                        }
                    }
                });

                // Start global progress update loop (only once)
                startProgressUpdateLoop();
            });

            video.addEventListener('pause', function() {
                // Sync pause to all other videos
                document.querySelectorAll('video').forEach(v => {
                    if (v !== video && !v.paused) {
                        v.pause();
                    }
                });
            });
            
            video.addEventListener('seeked', function() {
                updateVideoProgress(video);
            });
        }

        let currentAudioSource = 'original';
        let audioMuteStates = {
            original: false,
            editA: false,
            editB: false
        };

        function toggleAudioMute(source) {
            // Toggle mute state for this source
            audioMuteStates[source] = !audioMuteStates[source];
            
            console.log(`Toggling ${source} mute to:`, audioMuteStates[source]);
            
            // Apply mute state IMMEDIATELY using volume (more reliable than muted property)
            applyAudioMuteImmediate(source);
            
            // Update button appearance
            const slotName = source.charAt(0).toUpperCase() + source.slice(1);
            const button = document.getElementById(`audio${slotName}`);
            if (!button) {
                console.log(`Button audio${slotName} not found`);
                return;
            }
            
            const icon = button.querySelector('.audio-mute-icon');
            
            if (audioMuteStates[source]) {
                button.classList.add('muted');
                icon.textContent = 'üîá';
            } else {
                button.classList.remove('muted');
                icon.textContent = 'üîä';
            }
            
            // If this was the selected audio source, switch to an unmuted source
            if (source === currentAudioSource && audioMuteStates[source]) {
                // Find first unmuted source
                const unmutedSource = Object.keys(audioMuteStates).find(s => !audioMuteStates[s] && mediaData[s]);
                if (unmutedSource) {
                    selectAudioSource(unmutedSource);
                }
            }
        }

        function applyAudioMuteImmediate(source) {
            const slotName = source.charAt(0).toUpperCase() + source.slice(1);
            const layer = document.getElementById(`layer${slotName}`);
            
            if (layer) {
                const video = layer.querySelector('video');
                if (video) {
                    const shouldBeMuted = audioMuteStates[source];
                    video.muted = shouldBeMuted;
                    console.log(`Applied ${source}: muted=${video.muted}`);
                } else {
                    console.log(`No video found in layer ${slotName}`);
                }
            } else {
                console.log(`Layer ${slotName} not found`);
            }
        }

        function selectAudioSource(source) {
            currentAudioSource = source;

            // Update button states
            document.getElementById('audioOriginal').classList.toggle('active', source === 'original');
            document.getElementById('audioEditA').classList.toggle('active', source === 'editA');
            document.getElementById('audioEditB').classList.toggle('active', source === 'editB');

            // Mute all videos except the selected source and update button icons
            ['original', 'editA', 'editB'].forEach(slot => {
                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const layer = document.getElementById(`layer${slotName}`);
                const button = document.getElementById(`audio${slotName}`);
                const icon = button ? button.querySelector('.audio-mute-icon') : null;

                if (layer) {
                    const video = layer.querySelector('video');
                    if (video) {
                        // Mute if not the selected source OR if individually muted
                        const shouldMute = (slot !== source) || audioMuteStates[slot];
                        video.muted = shouldMute;

                        // Update mute icon to reflect actual state
                        if (button && icon) {
                            if (shouldMute) {
                                button.classList.add('muted');
                                icon.textContent = 'üîá';
                            } else {
                                button.classList.remove('muted');
                                icon.textContent = 'üîä';
                            }
                        }
                    }

                    // Add active-audio class to layer with unmuted audio in split views
                    if (slot === source && !audioMuteStates[slot]) {
                        layer.classList.add('active-audio');
                    } else {
                        layer.classList.remove('active-audio');
                    }
                }
            });
        }

        function setVolume(value) {
            const volume = value / 100;
            document.querySelectorAll('.overlay-layer video').forEach(v => {
                v.volume = volume;
            });
            // Volume label removed in compact redesign
        }

        function updateVideoProgress(video) {
            const currentTime = video.currentTime;
            const duration = video.duration;

            // Guard against NaN when video metadata isn't ready yet
            if (isNaN(duration) || duration === 0) {
                document.getElementById('videoProgressBar').style.width = '0%';
                document.getElementById('videoTimecode').textContent = '0:00:00';
                document.getElementById('videoDuration').textContent = '0:00:00';
                return;
            }

            const progress = (currentTime / duration) * 100;

            // Update progress bar
            document.getElementById('videoProgressBar').style.width = progress + '%';

            // Get framerate (assume 30fps if not detected)
            const fps = videoFrameRates[video.src] || 30;

            if (timecodeMode === 'frames') {
                // Frame mode: "Frame 462" and "3720"
                const currentFrame = Math.floor(currentTime * fps);
                const totalFrames = Math.floor(duration * fps);
                document.getElementById('videoTimecode').textContent = `Frame ${currentFrame}`;
                document.getElementById('videoDuration').textContent = `${totalFrames}`;
            } else {
                // Time mode: "0:15:22" and "2:35:18" (min:sec:frame)
                const currentMinutes = Math.floor(currentTime / 60);
                const currentSeconds = Math.floor(currentTime % 60);
                const currentFrames = Math.floor((currentTime % 1) * fps);

                const totalMinutes = Math.floor(duration / 60);
                const totalSeconds = Math.floor(duration % 60);
                const totalFrames = Math.floor((duration % 1) * fps);

                const currentTC = `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}:${currentFrames.toString().padStart(2, '0')}`;
                const totalTC = `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}:${totalFrames.toString().padStart(2, '0')}`;

                document.getElementById('videoTimecode').textContent = currentTC;
                document.getElementById('videoDuration').textContent = totalTC;
            }
        }

        function toggleTimecodeMode() {
            timecodeMode = timecodeMode === 'time' ? 'frames' : 'time';
            // Update display immediately
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const video = activeLayer.querySelector('video');
                if (video) {
                    updateVideoProgress(video);
                }
            }
        }

        function toggleQuickStart() {
            const popup = document.getElementById('quickStartPopup');
            
            if (popup.classList.contains('show')) {
                popup.classList.remove('show');
            } else {
                popup.classList.add('show');
            }
        }

        function checkForIdenticalAssets() {
            const identicalPairs = [];

            const slots = ['original', 'editA', 'editB'];
            const labels = {
                'original': 'Original',
                'editA': 'Edit A',
                'editB': 'Edit B'
            };
            
            // Get aspect ratios for all assets
            const aspectRatios = {};
            slots.forEach(slot => {
                if (mediaData[slot]) {
                    const layer = document.getElementById(`layer${slot.charAt(0).toUpperCase() + slot.slice(1)}`);
                    const media = layer.querySelector('img, video');
                    if (media) {
                        const w = media.naturalWidth || media.videoWidth || 0;
                        const h = media.naturalHeight || media.videoHeight || 0;
                        aspectRatios[slot] = { 
                            width: w, 
                            height: h, 
                            ratio: w / h,
                            formatted: `${w}√ó${h}`
                        };
                    }
                }
            });
            
            // Compare all pairs for identical content
            for (let i = 0; i < slots.length; i++) {
                for (let j = i + 1; j < slots.length; j++) {
                    const slot1 = slots[i];
                    const slot2 = slots[j];
                    
                    if (mediaData[slot1] && mediaData[slot2]) {
                        // Compare data URLs (includes entire file content)
                        if (mediaData[slot1].src === mediaData[slot2].src) {
                            identicalPairs.push(`${labels[slot1]} = ${labels[slot2]}`);
                        }
                        
                        // Aspect ratio mismatch check (muted for now ‚Äî will revisit)
                        // if (aspectRatios[slot1] && aspectRatios[slot2]) {
                        //     const ratio1 = aspectRatios[slot1].ratio;
                        //     const ratio2 = aspectRatios[slot2].ratio;
                        //     const difference = Math.abs(ratio1 - ratio2) / ratio1 * 100;
                        //     if (difference > 0.5) {
                        //         distortionWarnings.push(
                        //             `${labels[slot1]} (${aspectRatios[slot1].formatted}) vs ${labels[slot2]} (${aspectRatios[slot2].formatted}) - ${difference.toFixed(1)}% aspect ratio difference`
                        //         );
                        //     }
                        // }
                    }
                }
            }
            
            // Build combined warning message
            const warnings = [];
            if (identicalPairs.length > 0) {
                warnings.push(`Identical: ${identicalPairs.join(', ')}`);
            }

            
            // Show warning if any issues found
            const warningEl = document.getElementById('identicalWarning');
            if (warnings.length > 0) {
                warningEl.innerHTML = `‚ö†Ô∏è ${warnings.join(' | ')}`;
                warningEl.classList.add('show');
                
                // Auto-hide after 15 seconds (longer since there may be more info)
                setTimeout(() => {
                    warningEl.classList.remove('show');
                }, 15000);
            }
        }

        function switchToAsset(index) {
            // Save state before switching
            if (document.getElementById('comparisonView').classList.contains('active')) {
                saveState();
            }
            
            // Skip empty slots
            const assetKey = assetOrder[index];
            if (!mediaData[assetKey]) {
                // If this slot is empty, try the next one
                const nextIndex = (index + 1) % assetOrder.length;
                if (nextIndex !== index) {
                    switchToAsset(nextIndex);
                }
                return;
            }
            
            currentAssetIndex = index;

            // Always switch audio to the selected video
            selectAudioSource(assetKey);
            
            // Hide all layers (only in overlay mode)
            if (!isSideBySide) {
                console.log('Overlay mode - hiding all layers');
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    layer.classList.remove('active');
                });

                // Show selected layer
                const layerName = assetKey.charAt(0).toUpperCase() + assetKey.slice(1);
                const activeLayer = document.getElementById(`layer${layerName}`);
                console.log(`Activating layer: layer${layerName}`, activeLayer);
                if (activeLayer) {
                    activeLayer.classList.add('active');
                    console.log(`Layer activated, has media:`, activeLayer.querySelector('img, video') !== null);
                } else {
                    console.error(`Layer layer${layerName} not found!`);
                }

                // Recompute normalization with all currently-loaded dimensions
                positionLabelsToMedia();
            }

            // Check if current asset is video and update progress if so
            const layerName = assetKey.charAt(0).toUpperCase() + assetKey.slice(1);
            const activeLayer = document.getElementById(`layer${layerName}`);
            const video = activeLayer.querySelector('video');
            if (video) {
                updateVideoProgress(video);
            }

            // Apply current pan offset if in fullscreen
            if (isFullscreen) {
                const img = activeLayer.querySelector('img, video');
                if (img) {
                    img.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
                }
            }

        }

        // Setup video scrubbing with drag support
        document.addEventListener('DOMContentLoaded', function() {
            const progressContainer = document.getElementById('videoProgressContainer');
            let isDragging = false;
            let wasPlaying = false;
            
            function scrubToPosition(e) {
                const activeLayer = document.querySelector('.overlay-layer.active');
                if (activeLayer) {
                    const video = activeLayer.querySelector('video');
                    if (video) {
                        const rect = progressContainer.getBoundingClientRect();
                        const clickX = e.clientX - rect.left;
                        const percentage = Math.max(0, Math.min(1, clickX / rect.width));
                        video.currentTime = percentage * video.duration;
                        
                        // Also scrub all other videos to same position
                        document.querySelectorAll('.overlay-layer video').forEach(v => {
                            if (v !== video) {
                                v.currentTime = percentage * v.duration;
                            }
                        });
                        
                        updateVideoProgress(video);
                    }
                }
            }
            
            progressContainer.addEventListener('mousedown', function(e) {
                isDragging = true;
                
                // Pause video during scrubbing for smooth experience
                const activeLayer = document.querySelector('.overlay-layer.active');
                if (activeLayer) {
                    const video = activeLayer.querySelector('video');
                    if (video) {
                        wasPlaying = !video.paused;
                        if (wasPlaying) {
                            pauseAllVideos();
                        }
                    }
                }
                
                scrubToPosition(e);
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    scrubToPosition(e);
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    
                    // Resume playback if it was playing before
                    if (wasPlaying) {
                        playAllVideos();
                    }
                }
            });
        });

        function toggleFullscreen() {
            saveState(); // Save state before toggling
            isFullscreen = !isFullscreen;
            
            if (isFullscreen) {
                document.body.classList.add('fullscreen');

                // In split modes (tripartite, side-by-side, vertical-stack) all layers are
                // marked active so they all display. Inspect mode shows one at a time, so
                // reduce to just the currently selected asset. We'll restore on exit.
                if (isSideBySide) {
                    const assetKey = assetOrder[currentAssetIndex];
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.classList.remove('active');
                    });
                    const layerName = assetKey.charAt(0).toUpperCase() + assetKey.slice(1);
                    const targetLayer = document.getElementById(`layer${layerName}`);
                    if (targetLayer) targetLayer.classList.add('active');
                }

                // Find largest native dimensions across all loaded assets
                let maxNativeW = 0, maxNativeH = 0;
                ['original', 'editA', 'editB'].forEach(slot => {
                    if (mediaData[slot]) {
                        const layer = document.getElementById(`layer${slot.charAt(0).toUpperCase() + slot.slice(1)}`);
                        const media = layer.querySelector('img, video');
                        if (media) {
                            maxNativeW = Math.max(maxNativeW, media.naturalWidth || media.videoWidth || 0);
                            maxNativeH = Math.max(maxNativeH, media.naturalHeight || media.videoHeight || 0);
                        }
                    }
                });

                // Fit largest asset to viewport. Use window.innerWidth/Height ‚Äî always the
                // true CSS viewport size regardless of content overflow. Header is
                // position:absolute in fullscreen so subtract its height visually.
                const HEADER_OVERLAP = 50;
                const viewW = window.innerWidth;
                const viewH = window.innerHeight - HEADER_OVERLAP;
                fitZoom = (maxNativeW > 0 && maxNativeH > 0)
                    ? Math.min(viewW / maxNativeW, viewH / maxNativeH)
                    : 1;

                zoomLevel = fitZoom;
                panOffsetX = 0;
                panOffsetY = 0;
                applyZoom();
                setupPanHandlers();
                showPanHint();
            } else {
                document.body.classList.remove('fullscreen');

                // Restore split-mode active state: in tripartite/side-by-side/vertical-stack
                // all layers with media should be active again.
                if (isSideBySide) {
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        if (layer.querySelector('img, video')) {
                            layer.classList.add('active');
                        }
                    });
                }

                // Reset wrapper position back to absolute (was set to fixed in inspect mode)
                document.querySelectorAll('.overlay-layer .video-wrapper').forEach(vw => {
                    vw.style.position = '';
                });

                // Reset to normal scaling
                document.querySelectorAll('.overlay-layer img, .overlay-layer video').forEach(media => {
                    media.style.imageRendering = '';
                    media.style.width = '';
                    media.style.height = '';
                    // Don't override maxWidth/maxHeight in split modes (CSS handles those)
                    if (!isSideBySide && !document.body.classList.contains('vertical-stack')) {
                        media.style.maxWidth = '100%';
                        media.style.maxHeight = '100%';
                    } else {
                        media.style.maxWidth = '';
                        media.style.maxHeight = '';
                    }
                    media.style.transform = '';
                    media.style.objectFit = '';
                });

                // Re-run label positioning so info bar and wrapper are placed correctly
                // (CSS removes the fullscreen flex overrides once body.fullscreen is gone)
                requestAnimationFrame(() => positionLabelsToMedia());
                
                // Reset pan state and zoom
                panOffsetX = 0;
                panOffsetY = 0;
                zoomLevel = 1;

                // Remove pan handlers
                const container = document.getElementById('overlayContainer');
                container.removeEventListener('mousedown', handlePanStart);
                container.removeEventListener('mousemove', handlePanMove);
                container.removeEventListener('mouseup', handlePanEnd);
                container.removeEventListener('mouseleave', handlePanEnd);
                container.classList.remove('panning');
            }
        }

        function applyZoom() {
            // Find the largest dimensions across all loaded assets
            let maxWidth = 0;
            let maxHeight = 0;
            
            ['original', 'editA', 'editB'].forEach(slot => {
                if (mediaData[slot]) {
                    const layer = document.getElementById(`layer${slot.charAt(0).toUpperCase() + slot.slice(1)}`);
                    const media = layer.querySelector('img, video');
                    if (media) {
                        const w = media.naturalWidth || media.videoWidth || 0;
                        const h = media.naturalHeight || media.videoHeight || 0;
                        maxWidth = Math.max(maxWidth, w);
                        maxHeight = Math.max(maxHeight, h);
                    }
                }
            });
            
            if (isFullscreen) {
                const scaledW = Math.round(maxWidth * zoomLevel);
                const scaledH = Math.round(maxHeight * zoomLevel);

                // True split modes (side-by-side, vertical-stack): each wrapper is
                // absolute-positioned inside its own cell ‚Äî preserve top/left, just resize.
                // Overlay and tripartite: center the wrapper in the full viewport using
                // explicit math. isSideBySide is true for tripartite too so we can't use
                // it as the guard ‚Äî check body classes directly.
                const isTrueSplit = document.body.classList.contains('side-by-side') ||
                                    document.body.classList.contains('vertical-stack');

                if (isTrueSplit) {
                    document.querySelectorAll('.overlay-layer .video-wrapper').forEach(vw => {
                        vw.style.width = scaledW + 'px';
                        vw.style.height = scaledH + 'px';
                    });
                } else {
                    // Center wrapper in the area below the header using position:fixed so
                    // it escapes any parent clipping (tripartite grid cells have overflow:hidden).
                    // HEADER_OVERLAP matches the value used when computing fitZoom.
                    const HEADER_OVERLAP = 50;
                    const availH = window.innerHeight - HEADER_OVERLAP;
                    const centerTop = HEADER_OVERLAP + Math.max(0, Math.round((availH - scaledH) / 2));
                    const centerLeft = Math.max(0, Math.round((window.innerWidth - scaledW) / 2));
                    document.querySelectorAll('.overlay-layer .video-wrapper').forEach(vw => {
                        vw.style.position = 'fixed';
                        vw.style.top = centerTop + 'px';
                        vw.style.left = centerLeft + 'px';
                        vw.style.width = scaledW + 'px';
                        vw.style.height = scaledH + 'px';
                    });
                    // Clear info bar inline styles so CSS display:none !important applies
                    document.querySelectorAll('.overlay-layer .asset-info-bar').forEach(bar => {
                        bar.style.cssText = '';
                    });
                }

                // img/video fills its wrapper 100%√ó100% ‚Äî wrapper is sized above.
                document.querySelectorAll('.overlay-layer img, .overlay-layer video').forEach(media => {
                    media.style.imageRendering = 'pixelated';
                    media.style.width = '100%';
                    media.style.height = '100%';
                    media.style.maxWidth = 'none';
                    media.style.maxHeight = 'none';
                    media.style.objectFit = 'contain';
                });
            }
            
            // Always show the numeric zoom ratio (rendered pixels √∑ native pixels).
            const zoomText = zoomLevel.toFixed(2) + '√ó';
            document.getElementById('zoomIndicator').textContent = zoomText;
            // In inspect mode, sync per-asset corner badges to the same zoom value.
            // Outside inspect, positionLabelsToMedia() keeps them accurate.
            if (isFullscreen) {
                document.querySelectorAll('.overlay-layer .split-zoom-indicator').forEach(ind => {
                    ind.textContent = zoomText;
                });
            }
        }

        function zoomIn() {
            if (!isFullscreen) return;
            zoomLevel = Math.min(zoomLevel * ZOOM_STEP, ZOOM_MAX);
            applyZoom();

            // Reapply pan offset to active image
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const img = activeLayer.querySelector('img, video');
                if (img) img.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
            }
        }

        function zoomOut() {
            if (!isFullscreen) return;
            zoomLevel = Math.max(zoomLevel / ZOOM_STEP, ZOOM_MIN);
            applyZoom();

            // Reapply pan offset to active image
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const img = activeLayer.querySelector('img, video');
                if (img) img.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
            }
        }

        let panHintTimer = null;
        function showPanHint() {
            const hint = document.querySelector('.pan-hint');
            if (!hint) return;
            // Clear any running timer and reset
            clearTimeout(panHintTimer);
            hint.classList.add('visible');
            panHintTimer = setTimeout(() => {
                hint.classList.remove('visible');
            }, 2500);
        }

        function resetFitZoom() {
            if (!isFullscreen) return;
            zoomLevel = fitZoom;
            panOffsetX = 0;
            panOffsetY = 0;
            applyZoom();
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const img = activeLayer.querySelector('img, video');
                if (img) img.style.transform = '';
            }
        }

        function setupPanHandlers() {
            const container = document.getElementById('overlayContainer');
            
            container.addEventListener('mousedown', handlePanStart);
            container.addEventListener('mousemove', handlePanMove);
            container.addEventListener('mouseup', handlePanEnd);
            container.addEventListener('mouseleave', handlePanEnd);
        }

        function handlePanStart(e) {
            e.preventDefault(); // Prevent browser's default drag behavior
            isPanning = true;
            panStartX = e.clientX - panOffsetX;
            panStartY = e.clientY - panOffsetY;
            document.getElementById('overlayContainer').classList.add('panning');
        }

        function handlePanMove(e) {
            if (!isPanning) return;
            
            e.preventDefault();
            panOffsetX = e.clientX - panStartX;
            panOffsetY = e.clientY - panStartY;
            
            // Apply transform to all active images
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const img = activeLayer.querySelector('img, video');
                if (img) {
                    img.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
                }
            }
        }

        function handlePanEnd(e) {
            isPanning = false;
            document.getElementById('overlayContainer').classList.remove('panning');
        }

        // Clear all loaded media and reset state ‚Äî called both by resetAll() and at the
        // start of handleMultipleFiles() so a fresh load always starts from a clean state.
        function clearAllMedia() {
            mediaData.original = null;
            mediaData.editA = null;
            mediaData.editB = null;
            currentAssetIndex = 0;
            isFullscreen = false;
            hasVideos = false;

            document.body.classList.remove('fullscreen');
            document.body.classList.remove('side-by-side');
            document.body.classList.remove('vertical-stack');
            document.body.classList.remove('tripartite');
            document.body.classList.remove('two-asset');
            isSideBySide = false;
            layoutMode = 'horizontal';

            // Restore all layers to visible for next load
            document.querySelectorAll('.overlay-layer').forEach(layer => {
                layer.style.display = '';
            });
            document.getElementById('comparisonView').classList.remove('active');
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('videoControls').classList.remove('active');

            // Clear layers
            ['Original', 'EditA', 'EditB'].forEach(slot => {
                const layer = document.getElementById(`layer${slot}`);
                // Remove media container
                const mediaContainer = layer.querySelector('.media-container');
                if (mediaContainer) {
                    mediaContainer.remove();
                }
                layer.classList.remove('active');

                // Reset info bar text
                const infoBar = layer.querySelector('.asset-info-bar');
                if (infoBar) {
                    infoBar.querySelector('.asset-resolution').textContent = '-';
                    infoBar.querySelector('.asset-aspect').textContent = '-';
                    infoBar.querySelector('.asset-duration').textContent = '-';
                }

                // Reset zoom indicator
                const zoomIndicator = layer.querySelector('.split-zoom-indicator');
                if (zoomIndicator) {
                    zoomIndicator.textContent = '1.0√ó';
                }
            });

            // Restore default asset labels (may have been changed to IMAGE/VIDEO A/B in 2-asset mode)
            document.querySelector('#layerEditA .asset-name').textContent = 'EDIT A';
            document.querySelector('#layerEditB .asset-name').textContent = 'EDIT B';

            // Reset file input
            document.getElementById('multiFileInput').value = '';
        }

        function resetAll() {
            if (confirm('Reset all assets and start over?')) {
                clearAllMedia();
            }
        }

        // Video controls
        function getAllVideos() {
            return [
                document.querySelector('#layerOriginal video'),
                document.querySelector('#layerEditA video'),
                document.querySelector('#layerEditB video')
            ].filter(v => v);
        }

        function playAllVideos() {
            getAllVideos().forEach(v => v.play());
        }

        function pauseAllVideos() {
            getAllVideos().forEach(v => v.pause());
        }

        function togglePlayPause() {
            const firstVideo = document.querySelector('.overlay-layer video');
            if (firstVideo) {
                if (firstVideo.paused) {
                    playAllVideos();
                } else {
                    pauseAllVideos();
                }
            }
        }

        function restartAllVideos() {
            getAllVideos().forEach(v => {
                v.currentTime = 0;
                v.play();
            });
        }

        let isSideBySide = false;
        let layoutMode = 'horizontal'; // 'horizontal' or 'vertical'
        
        function toggleSideBySide() {
            saveState(); // Save state before toggling
            isSideBySide = !isSideBySide;
            const btn = document.getElementById('sideBySideBtn');
            
            if (isSideBySide) {
                if (layoutMode === 'vertical') {
                    document.body.classList.add('vertical-stack');
                } else {
                    document.body.classList.add('side-by-side');
                }
                btn.textContent = 'Overlay';
                // Show all loaded layers
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    const hasMedia = layer.querySelector('img, video');
                    if (hasMedia) {
                        layer.classList.add('active');
                    }
                });
                setupLayerDragAndDrop();
            } else {
                document.body.classList.remove('side-by-side');
                document.body.classList.remove('vertical-stack');
                btn.textContent = 'Split View';
                // Return to single active layer
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    layer.classList.remove('active');
                });
                switchToAsset(currentAssetIndex);
                removeDragAndDrop();
            }
        }

        function updateSplitViewZoomIndicators() {
            // Only update in split view modes
            if (!isSideBySide && !document.body.classList.contains('vertical-stack')) {
                return;
            }
            
            ['original', 'editA', 'editB'].forEach(slot => {
                if (!mediaData[slot]) return;
                
                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const layer = document.getElementById(`layer${slotName}`);
                const media = layer.querySelector('img, video');
                const indicator = document.getElementById(`zoom${slotName}`);
                
                if (!media || !indicator) return;
                
                // Get native dimensions
                const nativeWidth = media.naturalWidth || media.videoWidth || 0;
                const nativeHeight = media.naturalHeight || media.videoHeight || 0;
                
                if (nativeWidth === 0 || nativeHeight === 0) return;
                
                // Get displayed dimensions
                const displayedWidth = media.offsetWidth;
                const displayedHeight = media.offsetHeight;
                
                // Calculate zoom based on width (primary dimension)
                const zoomX = displayedWidth / nativeWidth;
                const zoomY = displayedHeight / nativeHeight;
                
                // Use the smaller zoom to ensure fit
                const actualZoom = Math.min(zoomX, zoomY);
                
                // Update indicator
                indicator.textContent = actualZoom.toFixed(2) + '√ó';
            });
        }
        
        // Update zoom indicators when window resizes
        window.addEventListener('resize', updateSplitViewZoomIndicators);

        // Positions the video-wrapper and info bar to exactly match the rendered media bounds.
        // Works in all modes: overlay, horizontal split, and vertical split.
        // The video-wrapper is JS-sized to the exact rendered video pixels so that the
        // zoom indicator (position:absolute; bottom:5px; right:5px inside it) always lands
        // at the lower-right corner of the actual content, not the black letterbox area.
        // The info bar is positioned:
        //   - Overlay/Horizontal: above the video-wrapper (top edge)
        //   - Vertical: to the left of the video-wrapper
        function positionLabelsToMedia(retriesLeft = 5) {
            // In inspect mode, applyZoom() owns all wrapper positions. Skip so we don't
            // clobber the centered top/left values it computes (debounce timer can fire
            // after toggleFullscreen sets up centering).
            if (isFullscreen) return;

            let anySkipped = false; // tracks if any slot had zero-dimension container (needs retry)
            const slots = ['original', 'editA', 'editB'];
            const isVertical = document.body.classList.contains('vertical-stack');
            const isTripartite = document.body.classList.contains('tripartite');
            const isOverlay = !isSideBySide && !isVertical;

            // In overlay mode, normalize assets to display at the same screen footprint:
            //   Portrait (w < h): normalize to the same contain-fit WIDTH
            //   Landscape (w >= h): normalize to the same contain-fit HEIGHT
            // Reference = smallest value in that dimension across loaded slots of that orientation.
            // All others scale down to match, so stepping through assets feels like the same image size.
            const normalizeScales = {}; // slot ‚Üí multiplier (‚â§ 1) to apply to contain-fit renderedW/H
            if (isOverlay) {
                // Pass 1: compute each slot's contain-fit rendered width and height.
                // Reserve INFO_BAR_H pixels at the top so the info bar always has room
                // to float above the image without overlapping it.
                const INFO_BAR_H = 30; // matches approximate asset-info-bar height
                const fitDims = {}; // slot ‚Üí { fw, fh, portrait }
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                    const layer = document.getElementById(`layer${slotName}`);
                    const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                    const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                    if (!media) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    const cw = mediaContainer.offsetWidth;
                    const ch = mediaContainer.offsetHeight;
                    if (!cw || !ch) { anySkipped = true; return; }
                    const aspect = nw / nh;
                    // Subtract INFO_BAR_H from available height so the image never fills
                    // flush to the top ‚Äî the bar can always sit above it.
                    const availH = ch - INFO_BAR_H;
                    const containerAspect = cw / availH;
                    let fw, fh;
                    if (containerAspect > aspect) { fh = availH; fw = fh * aspect; }
                    else { fw = cw; fh = fw / aspect; }
                    fitDims[slot] = { fw, fh, portrait: nw < nh };
                });

                // Pass 2: find the minimum contain-fit width (portraits) and height (landscapes),
                // capped at the minimum native dimension so we never scale any asset above 1.0√ó.
                let minPortraitW = Infinity, minLandscapeH = Infinity;
                slots.forEach(slot => {
                    const d = fitDims[slot];
                    if (!d) return;
                    const media = document.getElementById(`layer${slot.charAt(0).toUpperCase() + slot.slice(1)}`)
                        ?.querySelector('img, video');
                    const nw = media ? (media.naturalWidth || media.videoWidth || 0) : 0;
                    const nh = media ? (media.naturalHeight || media.videoHeight || 0) : 0;
                    if (d.portrait) {
                        // Cap at native width so no asset exceeds 1.0√ó zoom
                        minPortraitW = Math.min(minPortraitW, d.fw, nw);
                    } else {
                        // Cap at native height so no asset exceeds 1.0√ó zoom
                        minLandscapeH = Math.min(minLandscapeH, d.fh, nh);
                    }
                });

                // Pass 3: scale each slot so its reference dimension matches the capped minimum
                slots.forEach(slot => {
                    const d = fitDims[slot];
                    if (!d) { normalizeScales[slot] = 1; return; }
                    if (d.portrait) {
                        normalizeScales[slot] = minPortraitW < Infinity ? minPortraitW / d.fw : 1;
                    } else {
                        normalizeScales[slot] = minLandscapeH < Infinity ? minLandscapeH / d.fh : 1;
                    }
                });
            }

            // In tripartite mode, compute a shared rendered dimension so all three assets
            // appear the same size. Mirrors overlay normalization: portrait assets (nw < nh)
            // share rendered WIDTH (same as minPortraitW in overlay); landscape assets share
            // rendered HEIGHT (same as minLandscapeH in overlay).
            // Original is flush-right; A/B are flush-left at the A/B boundary.
            const tripartiteLayout = {}; // slot ‚Üí { rw, rh, cw, ch, sharedZoom }
            if (isTripartite) {
                let minW = Infinity, minH = Infinity;
                let widthConstrained = false; // true = portrait assets ‚Üí share width; false ‚Üí share height
                slots.forEach(slot => {
                    if (!mediaData[slot]) return;
                    const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                    const layer = document.getElementById(`layer${slotName}`);
                    const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                    const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                    if (!media) return;
                    const nw = media.naturalWidth || media.videoWidth || 0;
                    const nh = media.naturalHeight || media.videoHeight || 0;
                    if (!nw || !nh) return;
                    // Use layer.offsetWidth/Height ‚Äî the true grid cell dimensions.
                    // mediaContainer is position:absolute so its offsetHeight may not
                    // reflect the grid row height correctly.
                    const cw = layer.offsetWidth;
                    const ch = layer.offsetHeight;
                    if (!cw || !ch) { anySkipped = true; return; }
                    // Mirror overlay mode: portrait = nw < nh ‚Üí width is the shared dimension
                    if (nw < nh) widthConstrained = true;
                    // Contain-fit rendered size within own cell
                    const fitW = Math.min(cw, Math.floor(ch * nw / nh));
                    const fitH = Math.min(ch, Math.floor(cw * nh / nw));
                    tripartiteLayout[slot] = { nw, nh, cw, ch, fitW, fitH };
                    minW = Math.min(minW, fitW);
                    minH = Math.min(minH, fitH);
                });
                // Apply shared dimension: same width (portrait) or same height (landscape)
                slots.forEach(slot => {
                    const d = tripartiteLayout[slot];
                    if (!d) return;
                    if (widthConstrained) {
                        // Portrait: share width, height follows aspect ratio, clamped to cell height
                        d.rw = minW;
                        d.rh = Math.min(d.ch, Math.round(minW * d.nh / d.nw));
                        d.sharedZoom = d.rw / d.nw;
                    } else {
                        // Landscape: share height, width follows aspect ratio, clamped to cell width
                        d.rh = minH;
                        d.rw = Math.min(d.cw, Math.round(minH * d.nw / d.nh));
                        d.sharedZoom = d.rh / d.nh;
                    }
                });
            }

            slots.forEach(slot => {
                if (!mediaData[slot]) return;

                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const layer = document.getElementById(`layer${slotName}`);
                const mediaContainer = layer ? layer.querySelector('.media-container') : null;
                const media = mediaContainer ? mediaContainer.querySelector('img, video') : null;
                const videoWrapper = mediaContainer ? mediaContainer.querySelector('.video-wrapper') : null;
                const infoBar = mediaContainer ? mediaContainer.querySelector('.asset-info-bar') : null;

                if (!media || !videoWrapper || !mediaContainer) return;

                // Get natural dimensions
                const naturalWidth = media.naturalWidth || media.videoWidth || 0;
                const naturalHeight = media.naturalHeight || media.videoHeight || 0;
                if (naturalWidth === 0 || naturalHeight === 0) return;

                // Get the container bounds
                const containerW = mediaContainer.offsetWidth;
                const containerH = mediaContainer.offsetHeight;
                if (containerW === 0 || containerH === 0) { anySkipped = true; return; }

                // Calculate the rendered content bounds within object-fit: contain
                const mediaAspect = naturalWidth / naturalHeight;
                const containerAspect = containerW / containerH;

                let renderedW, renderedH, offsetX, offsetY;
                if (containerAspect > mediaAspect) {
                    renderedH = containerH;
                    renderedW = renderedH * mediaAspect;
                    offsetX = (containerW - renderedW) / 2;
                    offsetY = 0;
                } else {
                    renderedW = containerW;
                    renderedH = renderedW / mediaAspect;
                    offsetX = 0;
                    offsetY = (containerH - renderedH) / 2;
                }

                // In overlay mode, scale down to the smallest asset's rendered area so all
                // assets occupy the same physical screen footprint. Center within the area
                // below the info bar (INFO_BAR_H reserved at top) so the bar always floats above.
                if (isOverlay && normalizeScales[slot] !== undefined) {
                    const INFO_BAR_H = 30;
                    const scale = normalizeScales[slot];
                    renderedW = renderedW * scale;
                    renderedH = renderedH * scale;
                    offsetX = (containerW - renderedW) / 2;
                    const availH = containerH - INFO_BAR_H;
                    offsetY = INFO_BAR_H + Math.max(0, (availH - renderedH) / 2);
                }

                // In tripartite mode: use the shared zoom dimensions computed in the pre-pass.
                // Original is flush-right in its cell; EditA/EditB are flush-left in theirs.
                // All three are vertically centered. This makes right-edge of Original meet
                // the left-edge of A/B at the column midpoint, with the whole group centered.
                if (isTripartite && tripartiteLayout[slot]) {
                    const td = tripartiteLayout[slot];
                    const tw = Math.round(td.rw);
                    const th = Math.round(td.rh);
                    // Original: vertically centered in its full-height cell.
                    // EditA: bottom-aligned in its cell (image sits at the A/B boundary).
                    // EditB: top-aligned in its cell (image sits at the A/B boundary).
                    // This places A and B adjacent at their shared edge, matching Original's midpoint.
                    let ty;
                    if (slot === 'original') {
                        ty = Math.round((td.ch - td.rh) / 2);
                    } else if (slot === 'editA') {
                        ty = Math.round(td.ch - td.rh); // flush bottom
                    } else {
                        ty = 0; // flush top
                    }
                    // Original: flush right; A/B: flush left
                    const tx = slot === 'original'
                        ? Math.round(td.cw - td.rw)
                        : 0;

                    videoWrapper.style.opacity = '0';
                    videoWrapper.style.width = tw + 'px';
                    videoWrapper.style.height = th + 'px';
                    videoWrapper.style.top = ty + 'px';
                    videoWrapper.style.left = tx + 'px';
                    videoWrapper.style.transform = '';
                    videoWrapper.style.transformOrigin = '';
                    videoWrapper.style.opacity = '';

                    const zoomIndicator = videoWrapper.querySelector('.split-zoom-indicator');
                    if (zoomIndicator) {
                        zoomIndicator.textContent = td.sharedZoom.toFixed(2) + '√ó';
                    }

                    if (infoBar) {
                        const ibH = infoBar.offsetHeight || 28;
                        infoBar.style.left = tx + 'px';
                        infoBar.style.width = tw + 'px';
                        infoBar.style.height = '';
                        infoBar.style.right = '';
                        if (slot === 'editB') {
                            // EditB is flush-top; place bar just inside the top of the image
                            infoBar.style.top = ty + 'px';
                            infoBar.style.bottom = '';
                        } else {
                            // Original and EditA: bar above the image, clamped to 0
                            infoBar.style.top = Math.round(Math.max(0, ty - ibH)) + 'px';
                            infoBar.style.bottom = '';
                        }
                    }
                    return; // skip the standard positioning below
                }

                // Size and position the video-wrapper to exactly cover the rendered media pixels.
                // Hide during the write so the browser never paints an intermediate state.
                videoWrapper.style.opacity = '0';
                videoWrapper.style.width = Math.round(renderedW) + 'px';
                videoWrapper.style.height = Math.round(renderedH) + 'px';
                videoWrapper.style.top = Math.round(offsetY) + 'px';
                videoWrapper.style.left = Math.round(offsetX) + 'px';
                videoWrapper.style.transform = '';
                videoWrapper.style.transformOrigin = '';
                videoWrapper.style.opacity = '';

                // Update zoom indicator to reflect actual displayed size
                const zoomIndicator = videoWrapper.querySelector('.split-zoom-indicator');
                if (zoomIndicator) {
                    const actualZoom = renderedW / naturalWidth;
                    zoomIndicator.textContent = actualZoom.toFixed(2) + '√ó';
                }

                // Position the info bar above the video in all non-tripartite modes.
                // In overlay mode, offsetY is always >= INFO_BAR_H so there's always room.
                // In split modes, clamp to 0 so it never goes above the container boundary.
                if (infoBar) {
                    const ibH = infoBar.offsetHeight || 28;
                    infoBar.style.left = Math.round(offsetX) + 'px';
                    infoBar.style.top = Math.round(Math.max(0, offsetY - ibH)) + 'px';
                    infoBar.style.bottom = '';
                    infoBar.style.right = '';
                    infoBar.style.width = Math.round(renderedW) + 'px';
                    infoBar.style.height = '';
                }
            });

            // If any loaded slot had a zero-dimension container (layout not yet committed),
            // retry after the next paint so those slots get positioned correctly.
            // Cap retries to avoid infinite loops if a container is permanently zero.
            if (anySkipped && retriesLeft > 0) {
                requestAnimationFrame(() => positionLabelsToMedia(retriesLeft - 1));
            }
        }

        // Call positioning on resize
        window.addEventListener('resize', positionLabelsToMedia);

        function setViewMode(mode) {
            saveState(); // Save state before changing view
            
            // Update view mode
            if (mode === 'overlay') {
                // Return to overlay mode
                if (isSideBySide) {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.remove('tripartite');
                    document.body.classList.remove('two-asset');
                    isSideBySide = false;

                    // Restore all layers to visible so overlay mode can show them
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.style.display = '';
                    });

                    // Clear inline styles set by positionLabelsToMedia() so CSS takes over in overlay mode
                    document.querySelectorAll('.video-wrapper').forEach(vw => {
                        vw.style.width = '';
                        vw.style.height = '';
                        vw.style.top = '';
                        vw.style.left = '';
                    });

                    // Reset audio mute states and button icons when leaving split view
                    ['original', 'editA', 'editB'].forEach(slot => {
                        audioMuteStates[slot] = false;
                        const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                        const layer = document.getElementById(`layer${slotName}`);
                        if (layer) {
                            const video = layer.querySelector('video');
                            if (video) {
                                video.muted = false;
                            }
                        }
                        const button = document.getElementById(`audio${slotName}`);
                        if (button) {
                            button.classList.remove('muted');
                            const icon = button.querySelector('.audio-mute-icon');
                            if (icon) icon.textContent = 'üîä';
                        }
                    });

                    // Hide all layers except current
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        layer.classList.remove('active');
                        // Remove active-audio class when leaving split view
                        layer.classList.remove('active-audio');
                    });
                    switchToAsset(currentAssetIndex);
                    removeDragAndDrop();

                    // Two nested rAFs ensure CSS class removal reflow is complete
                    // before positionLabelsToMedia() reads container dimensions.
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            positionLabelsToMedia();
                        });
                    });
                }
            } else {
                // Enable split view
                if (!isSideBySide) {
                    isSideBySide = true;
                    document.querySelectorAll('.overlay-layer').forEach(layer => {
                        const hasMedia = layer.querySelector('img, video');
                        if (hasMedia) {
                            layer.classList.add('active');
                        }
                    });
                    if (mode !== 'tripartite') {
                        setupLayerDragAndDrop();
                    } else {
                        removeDragAndDrop();
                    }

                    // Ensure only the current audio source plays
                    selectAudioSource(currentAudioSource);
                }

                // Clear any inline styles set by positionLabelsToMedia() so CSS takes over
                document.querySelectorAll('.video-wrapper').forEach(vw => {
                    vw.style.width = '';
                    vw.style.height = '';
                    vw.style.top = '';
                    vw.style.left = '';
                    const zi = vw.querySelector('.split-zoom-indicator');
                    if (zi) { zi.style.bottom = ''; zi.style.right = ''; }
                });

                // Show/hide layers based on whether they have media loaded.
                // Empty layers must be hidden so they don't take up space in the layout.
                const loadedSlotCount = Object.values(mediaData).filter(m => m !== null).length;
                document.querySelectorAll('.overlay-layer').forEach(layer => {
                    const hasMedia = layer.querySelector('img, video');
                    layer.style.display = hasMedia ? '' : 'none';
                });
                // two-asset class drives /2 height in vertical-stack instead of /3
                if (loadedSlotCount === 2) {
                    document.body.classList.add('two-asset');
                } else {
                    document.body.classList.remove('two-asset');
                }

                // Set layout mode
                layoutMode = mode;
                if (mode === 'vertical') {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('tripartite');
                    document.body.classList.add('vertical-stack');
                } else if (mode === 'tripartite') {
                    document.body.classList.remove('side-by-side');
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.add('tripartite');
                    removeDragAndDrop();
                } else {
                    document.body.classList.remove('vertical-stack');
                    document.body.classList.remove('tripartite');
                    document.body.classList.add('side-by-side');
                    setupLayerDragAndDrop();
                }

                // Two nested rAFs guarantee a full layout pass with the new body class
                // applied before we read offsetWidth/offsetHeight to compute positions.
                // Opacity is managed per-slot inside positionLabelsToMedia() to avoid
                // race conditions when setViewMode() is called in rapid succession.
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        updateSplitViewZoomIndicators();
                        positionLabelsToMedia();
                    });
                });
            }

            // Update button visibility and active states
            updateViewModeButtons(mode);
        }

        function updateViewModeButtons(activeMode) {
            const overlayBtn = document.getElementById('overlayViewBtn');
            const horizontalBtn = document.getElementById('horizontalViewBtn');
            const verticalBtn = document.getElementById('verticalViewBtn');
            const tripartiteBtn = document.getElementById('tripartiteViewBtn');
            const loadedCount = Object.values(mediaData).filter(m => m !== null).length;
            const allThree = loadedCount === 3;
            // 2-asset mode has auto-picked layout; hide H/V buttons so user can't manually cycle
            const twoAssetAuto = loadedCount === 2 && !mediaData.original;
            const hideHV = allThree || twoAssetAuto;

            if (activeMode === 'overlay') {
                // In overlay mode: hide overlay btn, show split options appropriate to asset count
                overlayBtn.style.display = 'none';
                horizontalBtn.style.display = hideHV ? 'none' : 'inline-block';
                verticalBtn.style.display = hideHV ? 'none' : 'inline-block';
                tripartiteBtn.style.display = allThree ? 'inline-block' : 'none';
            } else {
                // In split mode: show overlay btn + mode-appropriate split buttons
                overlayBtn.style.display = 'inline-block';
                horizontalBtn.style.display = hideHV ? 'none' : 'inline-block';
                verticalBtn.style.display = hideHV ? 'none' : 'inline-block';
                tripartiteBtn.style.display = allThree ? 'inline-block' : 'none';

                // Reset all highlight styles
                overlayBtn.style.background = '';
                overlayBtn.style.color = '';
                horizontalBtn.style.background = activeMode === 'horizontal' ? 'rgb(160, 160, 160)' : '';
                horizontalBtn.style.color = activeMode === 'horizontal' ? '#000' : '';
                verticalBtn.style.background = activeMode === 'vertical' ? 'rgb(160, 160, 160)' : '';
                verticalBtn.style.color = activeMode === 'vertical' ? '#000' : '';
                tripartiteBtn.style.background = activeMode === 'tripartite' ? 'rgb(160, 160, 160)' : '';
                tripartiteBtn.style.color = activeMode === 'tripartite' ? '#000' : '';
            }
        }

        // Update checkAllLoaded to show view mode buttons
        function checkAllLoaded() {
            console.log('=== checkAllLoaded called ===');
            const loadedCount = Object.values(mediaData).filter(m => m !== null).length;
            console.log('Loaded count:', loadedCount);
            console.log('hasVideos:', hasVideos);
            
            // Need at least 2 files loaded (Edit A and Edit B minimum)
            if (loadedCount >= 2) {
                console.log('2+ files loaded, activating comparison view');
                
                // Hide quick start popup if showing
                document.getElementById('quickStartPopup').classList.remove('show');

                document.getElementById('comparisonView').classList.add('active');
                console.log('comparisonView activated');

                document.getElementById('resetBtn').style.display = 'block';

                // Show view mode buttons (initial state is overlay mode)
                // (updateViewModeButtons will set correct visibility based on asset count)
                console.log('View mode buttons shown');

                // Show/hide audio source buttons based on what's loaded
                document.getElementById('audioOriginal').style.display = mediaData.original ? 'inline-block' : 'none';
                document.getElementById('audioEditA').style.display = mediaData.editA ? 'inline-block' : 'none';
                document.getElementById('audioEditB').style.display = mediaData.editB ? 'inline-block' : 'none';
                console.log('Audio buttons configured');

                // Set initial audio source to first loaded video
                if (mediaData.original) {
                    selectAudioSource('original');
                } else if (mediaData.editA) {
                    selectAudioSource('editA');
                } else {
                    selectAudioSource('editB');
                }
                console.log('Audio source selected');

                // Check for identical assets
                checkForIdenticalAssets();
                
                // Start with first loaded asset
                console.log('About to switch to asset...');
                if (mediaData.original) {
                    console.log('Switching to Original (index 0)');
                    switchToAsset(0); // Start with original
                } else if (mediaData.editA) {
                    console.log('Switching to Edit A (index 1)');
                    switchToAsset(1); // Start with Edit A if no original
                } else {
                    console.log('Switching to Edit B (index 2)');
                    switchToAsset(2); // Start with Edit B
                }

                // 2-asset mode: relabel assets and auto-pick layout by dominant dimension.
                // 3-asset mode: always tripartite.
                if (loadedCount === 2 && !mediaData.original) {
                    // Relabel: IMAGE A/B or VIDEO A/B (no "EDIT" label when there's no original)
                    const mediaType = (mediaData.editA?.type === 'video' || mediaData.editB?.type === 'video')
                        ? 'VIDEO' : 'IMAGE';
                    document.querySelector('#layerEditA .asset-name').textContent = mediaType + ' A';
                    document.querySelector('#layerEditB .asset-name').textContent = mediaType + ' B';

                    // Auto-pick layout: landscape ‚Üí vertical stack, portrait ‚Üí side-by-side
                    const sample = mediaData.editA || mediaData.editB;
                    const isLandscape = (sample.w || 1) >= (sample.h || 1);
                    setViewMode(isLandscape ? 'vertical' : 'horizontal');
                } else {
                    setViewMode(loadedCount === 3 ? 'tripartite' : 'horizontal');
                }

                // Show video controls if any videos
                console.log('Checking for video controls, hasVideos =', hasVideos);
                if (hasVideos) {
                    console.log('Activating video controls');
                    const videoControls = document.getElementById('videoControls');
                    console.log('videoControls element:', videoControls);
                    videoControls.classList.add('active');
                    console.log('videoControls classes:', videoControls.className);
                } else {
                    console.log('No videos, controls will not show');
                }
                
                console.log('=== checkAllLoaded complete ===');
            } else {
                console.log('Not enough files loaded yet');
            }
        }

        function setupLayerDragAndDrop() {
            const layers = document.querySelectorAll('.overlay-layer');
            
            layers.forEach(layer => {
                if (!layer.querySelector('img, video')) return; // Skip empty layers
                
                layer.draggable = true;
                
                layer.addEventListener('dragstart', function(e) {
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.id);
                });
                
                layer.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                });
                
                layer.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');
                });
                
                layer.addEventListener('dragleave', function(e) {
                    this.classList.remove('drag-over');
                });
                
                layer.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    const draggedId = e.dataTransfer.getData('text/html');
                    const draggedElement = document.getElementById(draggedId);

                    if (draggedElement && draggedElement !== this) {
                        // Swap positions in DOM
                        const container = this.parentNode;
                        const allLayers = Array.from(container.querySelectorAll('.overlay-layer'));
                        const draggedIndex = allLayers.indexOf(draggedElement);
                        const targetIndex = allLayers.indexOf(this);

                        if (draggedIndex < targetIndex) {
                            this.parentNode.insertBefore(draggedElement, this.nextSibling);
                        } else {
                            this.parentNode.insertBefore(draggedElement, this);
                        }

                        // Sync order with drop zones and asset array
                        syncLayerOrderWithDropZones();
                    }
                });
            });
        }

        function removeDragAndDrop() {
            const layers = document.querySelectorAll('.overlay-layer');
            layers.forEach(layer => {
                layer.draggable = false;
                // Remove all event listeners by cloning and replacing
                const newLayer = layer.cloneNode(true);
                layer.parentNode.replaceChild(newLayer, layer);
            });
        }

        function syncLayerOrderWithDropZones() {
            // Get current DOM order of layers
            const layers = Array.from(document.querySelectorAll('.overlay-layer'));
            const newOrder = layers.map(layer => {
                if (layer.id === 'layerOriginal') return 'original';
                if (layer.id === 'layerEditA') return 'editA';
                if (layer.id === 'layerEditB') return 'editB';
            }).filter(x => x);

            // Update assetOrder array
            assetOrder.length = 0;
            assetOrder.push(...newOrder);

            // Reorder drop zones to match
            const dropZonesContainer = document.querySelector('.drop-zones');
            newOrder.forEach(slot => {
                const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                const dropZone = document.getElementById(`drop${slotName}`);
                if (dropZone) {
                    dropZonesContainer.appendChild(dropZone);
                }
            });

            // Update currentAssetIndex to match new order
            const activeLayer = document.querySelector('.overlay-layer.active');
            if (activeLayer) {
                const newIndex = layers.indexOf(activeLayer);
                if (newIndex !== -1) {
                    currentAssetIndex = newIndex;
                }
            }
        }

        function captureState() {
            const state = {
                currentAssetIndex: currentAssetIndex,
                isFullscreen: isFullscreen,
                isSideBySide: isSideBySide,
                layoutMode: layoutMode,
                zoomLevel: zoomLevel,
                fitZoom: fitZoom,
                panOffsetX: panOffsetX,
                panOffsetY: panOffsetY,

                timecodeMode: timecodeMode,
                isMuted: isMuted,
                layerOrder: Array.from(document.querySelectorAll('.overlay-layer')).map(l => l.id),
                videoStates: {}
            };
            
            // Capture video playback states
            document.querySelectorAll('.overlay-layer video').forEach(video => {
                const layer = video.closest('.overlay-layer');
                state.videoStates[layer.id] = {
                    currentTime: video.currentTime,
                    paused: video.paused,
                    volume: video.volume
                };
            });
            
            return state;
        }

        function saveState() {
            const state = captureState();
            undoStack.push(state);
            
            // Limit stack size
            if (undoStack.length > MAX_UNDO_STATES) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is taken
            redoStack = [];
        }

        function undo() {
            if (undoStack.length === 0) {
                console.log('Nothing to undo');
                return;
            }
            
            // Save current state to redo stack
            redoStack.push(captureState());
            
            // Restore previous state
            const state = undoStack.pop();
            restoreState(state);
        }

        function redo() {
            if (redoStack.length === 0) {
                console.log('Nothing to redo');
                return;
            }
            
            // Save current state to undo stack
            undoStack.push(captureState());
            
            // Restore next state
            const state = redoStack.pop();
            restoreState(state);
        }

        function restoreState(state) {
            // Restore basic state
            currentAssetIndex = state.currentAssetIndex;
            zoomLevel = state.zoomLevel;
            fitZoom = (state.fitZoom !== undefined) ? state.fitZoom : 1;
            panOffsetX = state.panOffsetX;
            panOffsetY = state.panOffsetY;

            timecodeMode = state.timecodeMode;
            isMuted = state.isMuted;
            
            // Restore fullscreen
            if (state.isFullscreen !== isFullscreen) {
                toggleFullscreen();
            }
            
            // Restore split view
            if (state.isSideBySide !== isSideBySide) {
                toggleSideBySide();
            }
            
            // Restore layout mode
            if (state.layoutMode !== layoutMode) {
                setViewMode(state.layoutMode);
            }
            
            // Restore layer order
            const container = document.getElementById('overlayContainer');
            const layoutControls = document.getElementById('layoutControls');
            state.layerOrder.forEach(layerId => {
                const layer = document.getElementById(layerId);
                if (layer) {
                    container.appendChild(layer);
                }
            });
            // Keep layout controls at top
            container.insertBefore(layoutControls, container.firstChild);
            
            // Restore video states
            Object.keys(state.videoStates).forEach(layerId => {
                const layer = document.getElementById(layerId);
                if (layer) {
                    const video = layer.querySelector('video');
                    const videoState = state.videoStates[layerId];
                    if (video && videoState) {
                        video.currentTime = videoState.currentTime;
                        video.volume = videoState.volume;
                        if (videoState.paused) {
                            video.pause();
                        } else {
                            video.play();
                        }
                    }
                }
            });
            
            // Restore current asset view
            switchToAsset(state.currentAssetIndex);
            
            // Update UI
            document.getElementById('muteBtn').textContent = isMuted ? 'üîá Unmute' : 'üîä Mute';
            document.getElementById('zoomIndicator').textContent = zoomLevel.toFixed(2) + '√ó';
            
            console.log('State restored');
        }

        let isMuted = false;
        function toggleMute() {
            saveState(); // Save state before muting
            isMuted = !isMuted;
            const btn = document.getElementById('muteBtn');

            getAllVideos().forEach(v => {
                v.muted = isMuted;
            });

            btn.textContent = isMuted ? 'üîá' : 'üîä';
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Undo/Redo - works globally
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const modifier = isMac ? e.metaKey : e.ctrlKey;
            
            if (modifier && e.key === 'z' && e.shiftKey) {
                // Cmd+Shift+Z (Mac) or Ctrl+Shift+Z (PC) - Redo
                e.preventDefault();
                redo();
                return;
            } else if (modifier && e.key === 'z') {
                // Cmd+Z (Mac) or Ctrl+Z (PC) - Undo
                e.preventDefault();
                undo();
                return;
            }
            
            // L key opens file picker ‚Äî works at any time
            if (e.key === 'l' || e.key === 'L') {
                e.preventDefault();
                document.getElementById('multiFileInput').click();
                return;
            }

            // K key toggles shortcuts panel ‚Äî works at any time
            if (e.key === 'k' || e.key === 'K') {
                e.preventDefault();
                toggleShortcutsPanel();
                return;
            }

            // Only work if comparison view is active
            if (!document.getElementById('comparisonView').classList.contains('active')) {
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                // Move to previous non-empty slot
                let nextIndex = (currentAssetIndex - 1 + assetOrder.length) % assetOrder.length;
                let attempts = 0;
                while (!mediaData[assetOrder[nextIndex]] && attempts < 3) {
                    nextIndex = (nextIndex - 1 + assetOrder.length) % assetOrder.length;
                    attempts++;
                }
                if (mediaData[assetOrder[nextIndex]]) {
                    switchToAsset(nextIndex);
                    // In inspect mode from a split layout, switchToAsset won't hide other
                    // layers (isSideBySide=true). Force exactly one active layer, then
                    // re-center after the CSS layout update commits.
                    if (isFullscreen && isSideBySide) {
                        const assetKey = assetOrder[nextIndex];
                        document.querySelectorAll('.overlay-layer').forEach(l => l.classList.remove('active'));
                        const ln = assetKey.charAt(0).toUpperCase() + assetKey.slice(1);
                        document.getElementById(`layer${ln}`)?.classList.add('active');
                        requestAnimationFrame(() => applyZoom());
                    }
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                // Move to next non-empty slot
                let nextIndex = (currentAssetIndex + 1) % assetOrder.length;
                let attempts = 0;
                while (!mediaData[assetOrder[nextIndex]] && attempts < 3) {
                    nextIndex = (nextIndex + 1) % assetOrder.length;
                    attempts++;
                }
                if (mediaData[assetOrder[nextIndex]]) {
                    switchToAsset(nextIndex);
                    // In inspect mode from a split layout, switchToAsset won't hide other
                    // layers (isSideBySide=true). Force exactly one active layer, then
                    // re-center after the CSS layout update commits.
                    if (isFullscreen && isSideBySide) {
                        const assetKey = assetOrder[nextIndex];
                        document.querySelectorAll('.overlay-layer').forEach(l => l.classList.remove('active'));
                        const ln = assetKey.charAt(0).toUpperCase() + assetKey.slice(1);
                        document.getElementById(`layer${ln}`)?.classList.add('active');
                        requestAnimationFrame(() => applyZoom());
                    }
                }
            } else if (e.key === 'i' || e.key === 'I') {
                e.preventDefault();
                toggleFullscreen();
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleFullscreen();
            } else if (e.key === 'Escape') {
                // Escape always exits inspect ‚Äî never enters it.
                e.preventDefault();
                if (isFullscreen) toggleFullscreen();
            } else if (e.key === '+' || e.key === '=') {
                // Both + and = (no shift needed) zoom in.
                // Auto-enter inspect only from overlay (not from split modes).
                e.preventDefault();
                if (!isFullscreen && !isSideBySide) {
                    toggleFullscreen();
                }
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                // Both - and _ zoom out.
                // Auto-enter inspect only from overlay (not from split modes).
                e.preventDefault();
                if (!isFullscreen && !isSideBySide) {
                    toggleFullscreen();
                }
                zoomOut();
            } else if (e.key === '0') {
                e.preventDefault();
                resetFitZoom();
            } else if (e.key === ' ') {
                // Spacebar toggles play/pause for videos
                e.preventDefault();
                togglePlayPause();
            } else if (e.key === 'r' || e.key === 'R') {
                // R key restarts from beginning
                e.preventDefault();
                restartAllVideos();
            } else if (e.key === 'm' || e.key === 'M') {
                // M key toggles mute
                e.preventDefault();
                toggleMute();
            } else if (e.key === 'o' || e.key === 'O') {
                // O key toggles overlay <-> split (tripartite for 3 assets, auto-layout for 2).
                // If in inspect mode, exit it first so layout state is clean.
                e.preventDefault();
                if (isFullscreen) toggleFullscreen();
                const allThreeLoaded = Object.values(mediaData).filter(m => m !== null).length === 3;
                if (isSideBySide) {
                    setViewMode('overlay');
                } else if (allThreeLoaded) {
                    setViewMode('tripartite');
                } else {
                    setViewMode(layoutMode);
                }
            } else if (e.key === 's' || e.key === 'S') {
                // S key cycles through view modes depending on asset count.
                // If in inspect mode, exit it first so layout state is clean.
                e.preventDefault();
                if (isFullscreen) toggleFullscreen();
                const allThreeLoaded = Object.values(mediaData).filter(m => m !== null).length === 3;
                if (allThreeLoaded) {
                    // 3-asset cycle: overlay <-> tripartite
                    if (!isSideBySide) {
                        setViewMode('tripartite');
                    } else {
                        setViewMode('overlay');
                    }
                } else {
                    // 2-asset: toggle overlay <-> the auto-picked split layout
                    if (!isSideBySide) {
                        setViewMode(layoutMode); // return to auto-picked horizontal or vertical
                    } else {
                        setViewMode('overlay');
                    }
                }
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            
        });

        function toggleShortcutsPanel() {
            document.getElementById('shortcutsPanel').classList.toggle('open');
        }

        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const icon = document.getElementById('toggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

    </script>

    <div class="shortcuts-panel" id="shortcutsPanel">
        <div class="shortcuts-panel-header">
            <span>Keyboard Shortcuts</span>
            <button onclick="toggleShortcutsPanel()">‚úï</button>
        </div>
        <div class="shortcuts-list">
            <div class="shortcut-row"><span class="shortcut-key"><kbd>‚Üê</kbd> <kbd>‚Üí</kbd></span><span class="shortcut-desc">Switch asset</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>Space</kbd></span><span class="shortcut-desc">Play / Pause</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>R</kbd></span><span class="shortcut-desc">Restart</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>M</kbd></span><span class="shortcut-desc">Mute</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>O</kbd></span><span class="shortcut-desc">Toggle overlay / split</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>S</kbd></span><span class="shortcut-desc">Cycle split mode</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>I</kbd></span><span class="shortcut-desc">Enter / exit inspect</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>Esc</kbd></span><span class="shortcut-desc">Exit inspect</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>+</kbd> <kbd>-</kbd></span><span class="shortcut-desc">Zoom (enters inspect)</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>0</kbd></span><span class="shortcut-desc">Reset to fit</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>L</kbd></span><span class="shortcut-desc">Load files</span></div>
            <div class="shortcut-row"><span class="shortcut-key"><kbd>K</kbd></span><span class="shortcut-desc">Toggle this panel</span></div>
        </div>
    </div>

</body>
</html>
